# C AST Tree Structure

Complete nested structure from comprehensive.c

```
translation_unit [161] = '/**'
  comment [160] = '/**'
  preproc_include [164] = '#include <stdio.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<stdio.h>'
  preproc_include [164] = '#include <stdlib.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<stdlib.h>'
  preproc_include [164] = '#include <string.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<string.h>'
  preproc_include [164] = '#include <stdint.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<stdint.h>'
  preproc_include [164] = '#include <stdarg.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<stdarg.h>'
  preproc_include [164] = '#include <signal.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<signal.h>'
  comment [160] = '/**'
  preproc_def [165] = '#define MAX_SIZE 1024'
    #define [4] = '#define'
    name: identifier [1] = 'MAX_SIZE'
    value: preproc_arg [18] = '1024'
  comment [160] = '/**'
  preproc_function_def [166] = '#define SQUARE(x) ((x) * (x))'
    #define [4] = '#define'
    name: identifier [1] = 'SQUARE'
    parameters: preproc_params [167] = '(x)'
      ( [5] = '('
      identifier [1] = 'x'
      ) [8] = ')'
    value: preproc_arg [18] = '((x) * (x))'
  comment [160] = '/**'
  preproc_function_def [166]
    #define [4] = '#define'
    name: identifier [1] = 'DEBUG_PRINT'
    parameters: preproc_params [167] = '(fmt, ...)'
      ( [5] = '('
      identifier [1] = 'fmt'
      , [7] = ','
      ... [6] = '...'
      ) [8] = ')'
    value: preproc_arg [18] = 'printf("[DEBUG] " fmt "\n", ##__VA_ARGS__)'
  comment [160] = '// Conditional preprocessing constructs'
  preproc_ifdef [170] = '#ifdef DEBUG_BUILD'
    #ifdef [12] = '#ifdef'
    name: identifier [1] = 'DEBUG_BUILD'
    preproc_def [165] = '#define LOG_ENABLED 1'
      #define [4] = '#define'
      name: identifier [1] = 'LOG_ENABLED'
      value: preproc_arg [18] = '1'
    preproc_function_def [166]
      #define [4] = '#define'
      name: identifier [1] = 'LOG'
      parameters: preproc_params [167] = '(msg)'
        ( [5] = '('
        identifier [1] = 'msg'
        ) [8] = ')'
      value: preproc_arg [18] = 'printf("[LOG] %s\n", msg)'
    alternative: preproc_else [171] = '#else'
      #else [14] = '#else'
      preproc_def [165] = '#define LOG_ENABLED 0'
        #define [4] = '#define'
        name: identifier [1] = 'LOG_ENABLED'
        value: preproc_arg [18] = '0'
      preproc_function_def [166] = '#define LOG(msg)'
        #define [4] = '#define'
        name: identifier [1] = 'LOG'
        parameters: preproc_params [167] = '(msg)'
          ( [5] = '('
          identifier [1] = 'msg'
          ) [8] = ')'
    #endif [11] = '#endif'
  preproc_if [169]
    #if [9] = '#if'
    condition: binary_expression [290]
      left: preproc_defined [191] = 'defined(FEATURE_ADVANCED)'
        defined [21] = 'defined'
        ( [5] = '('
        identifier [1] = 'FEATURE_ADVANCED'
        ) [8] = ')'
      operator: || [29] = '||'
      right: preproc_defined [191] = 'defined(FEATURE_EXTENDED)'
        defined [21] = 'defined'
        ( [5] = '('
        identifier [1] = 'FEATURE_EXTENDED'
        ) [8] = ')'
    
 [10] = ''
    preproc_def [165] = '#define ADVANCED_FEATURES_AVAILABLE'
      #define [4] = '#define'
      name: identifier [1] = 'ADVANCED_FEATURES_AVAILABLE'
    preproc_ifdef [170] = '#ifdef FEATURE_ADVANCED'
      #ifdef [12] = '#ifdef'
      name: identifier [1] = 'FEATURE_ADVANCED'
      preproc_def [165] = '#define ADVANCED_MODE 1'
        #define [4] = '#define'
        name: identifier [1] = 'ADVANCED_MODE'
        value: preproc_arg [18] = '1'
      alternative: preproc_elif [172] = '#elif defined(FEATURE_EXTENDED)'
        #elif [15] = '#elif'
        condition: preproc_defined [191] = 'defined(FEATURE_EXTENDED)'
          defined [21] = 'defined'
          ( [5] = '('
          identifier [1] = 'FEATURE_EXTENDED'
          ) [8] = ')'
        
 [10] = ''
        preproc_def [165] = '#define ADVANCED_MODE 2'
          #define [4] = '#define'
          name: identifier [1] = 'ADVANCED_MODE'
          value: preproc_arg [18] = '2'
        alternative: preproc_else [171] = '#else'
          #else [14] = '#else'
          preproc_def [165] = '#define ADVANCED_MODE 0'
            #define [4] = '#define'
            name: identifier [1] = 'ADVANCED_MODE'
            value: preproc_arg [18] = '0'
      #endif [11] = '#endif'
    #endif [11] = '#endif'
  comment [160] = '// Preprocessor function-like macro calls'
  preproc_function_def [166] = '#define CONCAT(a, b) a##b'
    #define [4] = '#define'
    name: identifier [1] = 'CONCAT'
    parameters: preproc_params [167] = '(a, b)'
      ( [5] = '('
      identifier [1] = 'a'
      , [7] = ','
      identifier [1] = 'b'
      ) [8] = ')'
    value: preproc_arg [18] = 'a##b'
  preproc_function_def [166] = '#define STRINGIFY(x) #x'
    #define [4] = '#define'
    name: identifier [1] = 'STRINGIFY'
    parameters: preproc_params [167] = '(x)'
      ( [5] = '('
      identifier [1] = 'x'
      ) [8] = ')'
    value: preproc_arg [18] = '#x'
  preproc_function_def [166] = '#define IS_DEFINED(x) defined(x)'
    #define [4] = '#define'
    name: identifier [1] = 'IS_DEFINED'
    parameters: preproc_params [167] = '(x)'
      ( [5] = '('
      identifier [1] = 'x'
      ) [8] = ')'
    value: preproc_arg [18] = 'defined(x)'
  comment [160] = '// Forward declarations with documentation'
  struct_specifier [249] = 'struct Node'
    struct [96] = 'struct'
    name: type_identifier [362] = 'Node'
  ; [42] = ';'
  type_definition [199] = 'typedef struct Node Node;'
    typedef [44] = 'typedef'
    type: struct_specifier [249] = 'struct Node'
      struct [96] = 'struct'
      name: type_identifier [362] = 'Node'
    declarator: type_identifier [362] = 'Node'
    ; [42] = ';'
  comment [160] = '/**'
  type_definition [199]
    typedef [44] = 'typedef'
    type: primitive_type [93] = 'int'
    declarator: function_declarator [230]
      declarator: parenthesized_declarator [219] = '(*compare_fn)'
        ( [5] = '('
        pointer_declarator [226] = '*compare_fn'
          * [26] = '*'
          declarator: type_identifier [362] = 'compare_fn'
        ) [8] = ')'
      parameters: parameter_list [258] = '(const void *, const void *)'
        ( [5] = '('
        parameter_declaration [260] = 'const void *'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'void'
          declarator: abstract_pointer_declarator [229] = '*'
            * [26] = '*'
        , [7] = ','
        parameter_declaration [260] = 'const void *'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'void'
          declarator: abstract_pointer_declarator [229] = '*'
            * [26] = '*'
        ) [8] = ')'
    ; [42] = ';'
  comment [160] = '/**'
  type_definition [199] = 'typedef uint32_t user_id_t;'
    typedef [44] = 'typedef'
    type: primitive_type [93] = 'uint32_t'
    declarator: type_identifier [362] = 'user_id_t'
    ; [42] = ';'
  comment [160] = '/**'
  type_definition [199] = 'typedef enum {'
    typedef [44] = 'typedef'
    type: enum_specifier [247] = 'enum {'
      enum [94] = 'enum'
      body: enumerator_list [248] = '{'
        { [64] = '{'
        enumerator [256] = 'STATUS_OK = 0'
          name: identifier [1] = 'STATUS_OK'
          = [73] = '='
          value: number_literal [141] = '0'
        , [7] = ','
        comment [160] = '/**< Operation completed successfully */'
        enumerator [256] = 'STATUS_ERROR = -1'
          name: identifier [1] = 'STATUS_ERROR'
          = [73] = '='
          value: number_literal [141] = '-1'
        , [7] = ','
        comment [160] = '/**< General error occurred */'
        enumerator [256] = 'STATUS_INVALID = -2'
          name: identifier [1] = 'STATUS_INVALID'
          = [73] = '='
          value: number_literal [141] = '-2'
        comment [160] = '/**< Invalid parameters provided */'
        } [65] = '}'
    declarator: type_identifier [362] = 'status_t'
    ; [42] = ';'
  comment [160] = '/**'
  struct_specifier [249] = 'struct Point {'
    struct [96] = 'struct'
    name: type_identifier [362] = 'Point'
    body: field_declaration_list [251] = '{'
      { [64] = '{'
      field_declaration [253] = 'float x;'
        type: primitive_type [93] = 'float'
        declarator: field_identifier [360] = 'x'
        ; [42] = ';'
      comment [160] = '/**< X coordinate */'
      field_declaration [253] = 'float y;'
        type: primitive_type [93] = 'float'
        declarator: field_identifier [360] = 'y'
        ; [42] = ';'
      comment [160] = '/**< Y coordinate */'
      field_declaration [253] = 'const char *label;'
        type_qualifier [243] = 'const'
          const [82] = 'const'
        type: primitive_type [93] = 'char'
        declarator: pointer_declarator [226] = '*label'
          * [26] = '*'
          declarator: field_identifier [360] = 'label'
        ; [42] = ';'
      comment [160] = '/**< Optional descriptive label */'
      } [65] = '}'
  ; [42] = ';'
  comment [160] = '/**'
  type_definition [199] = 'typedef struct {'
    typedef [44] = 'typedef'
    type: struct_specifier [249] = 'struct {'
      struct [96] = 'struct'
      body: field_declaration_list [251] = '{'
        { [64] = '{'
        field_declaration [253] = 'int width;'
          type: primitive_type [93] = 'int'
          declarator: field_identifier [360] = 'width'
          ; [42] = ';'
        comment [160] = '/**< Rectangle width in units */'
        field_declaration [253] = 'int height;'
          type: primitive_type [93] = 'int'
          declarator: field_identifier [360] = 'height'
          ; [42] = ';'
        comment [160] = '/**< Rectangle height in units */'
        field_declaration [253] = 'struct Point origin;'
          type: struct_specifier [249] = 'struct Point'
            struct [96] = 'struct'
            name: type_identifier [362] = 'Point'
          declarator: field_identifier [360] = 'origin'
          ; [42] = ';'
        comment [160] = '/**< Origin point of the rectangle */'
        } [65] = '}'
    declarator: type_identifier [362] = 'Rectangle'
    ; [42] = ';'
  comment [160] = '/**'
  struct_specifier [249] = 'struct Node {'
    struct [96] = 'struct'
    name: type_identifier [362] = 'Node'
    body: field_declaration_list [251] = '{'
      { [64] = '{'
      field_declaration [253] = 'int data;'
        type: primitive_type [93] = 'int'
        declarator: field_identifier [360] = 'data'
        ; [42] = ';'
      comment [160] = '/**< Integer data payload */'
      field_declaration [253] = 'struct Node *next;'
        type: struct_specifier [249] = 'struct Node'
          struct [96] = 'struct'
          name: type_identifier [362] = 'Node'
        declarator: pointer_declarator [226] = '*next'
          * [26] = '*'
          declarator: field_identifier [360] = 'next'
        ; [42] = ';'
      comment [160] = '/**< Pointer to next node */'
      field_declaration [253] = 'struct Node *prev;'
        type: struct_specifier [249] = 'struct Node'
          struct [96] = 'struct'
          name: type_identifier [362] = 'Node'
        declarator: pointer_declarator [226] = '*prev'
          * [26] = '*'
          declarator: field_identifier [360] = 'prev'
        ; [42] = ';'
      comment [160] = '/**< Pointer to previous node */'
      } [65] = '}'
  ; [42] = ';'
  comment [160] = '/**'
  union_specifier [250] = 'union Value {'
    union [97] = 'union'
    name: type_identifier [362] = 'Value'
    body: field_declaration_list [251] = '{'
      { [64] = '{'
      field_declaration [253] = 'int i;'
        type: primitive_type [93] = 'int'
        declarator: field_identifier [360] = 'i'
        ; [42] = ';'
      comment [160] = '/**< Integer value */'
      field_declaration [253] = 'float f;'
        type: primitive_type [93] = 'float'
        declarator: field_identifier [360] = 'f'
        ; [42] = ';'
      comment [160] = '/**< Floating-point value */'
      field_declaration [253] = 'char str[32];'
        type: primitive_type [93] = 'char'
        declarator: array_declarator [236] = 'str[32]'
          declarator: field_identifier [360] = 'str'
          [ [70] = '['
          size: number_literal [141] = '32'
          ] [72] = ']'
        ; [42] = ';'
      comment [160] = '/**< String value with fixed size */'
      field_declaration [253] = 'void *ptr;'
        type: primitive_type [93] = 'void'
        declarator: pointer_declarator [226] = '*ptr'
          * [26] = '*'
          declarator: field_identifier [360] = 'ptr'
        ; [42] = ';'
      comment [160] = '/**< Generic pointer value */'
      } [65] = '}'
  ; [42] = ';'
  comment [160] = '/**'
  struct_specifier [249]
    struct [96] = 'struct'
    attribute_specifier [205] = '__attribute__((packed))'
      __attribute__ [46] = '__attribute__'
      ( [5] = '('
      argument_list [309] = '(packed)'
        ( [5] = '('
        identifier [1] = 'packed'
        ) [8] = ')'
      ) [8] = ')'
    name: type_identifier [362] = 'PackedData'
    body: field_declaration_list [251] = '{'
      { [64] = '{'
      field_declaration [253] = 'char flag;'
        type: primitive_type [93] = 'char'
        declarator: field_identifier [360] = 'flag'
        ; [42] = ';'
      comment [160] = '/**< Single byte flag */'
      field_declaration [253] = 'int value;'
        type: primitive_type [93] = 'int'
        declarator: field_identifier [360] = 'value'
        ; [42] = ';'
      comment [160] = '/**< 4-byte integer (no padding) */'
      field_declaration [253] = 'char data[3];'
        type: primitive_type [93] = 'char'
        declarator: array_declarator [236] = 'data[3]'
          declarator: field_identifier [360] = 'data'
          [ [70] = '['
          size: number_literal [141] = '3'
          ] [72] = ']'
        ; [42] = ';'
      comment [160] = '/**< 3-byte array */'
      } [65] = '}'
    attribute_specifier [205] = '__attribute__((aligned(8)))'
      __attribute__ [46] = '__attribute__'
      ( [5] = '('
      argument_list [309] = '(aligned(8))'
        ( [5] = '('
        call_expression [299] = 'aligned(8)'
          function: identifier [1] = 'aligned'
          arguments: argument_list [309] = '(8)'
            ( [5] = '('
            number_literal [141] = '8'
            ) [8] = ')'
        ) [8] = ')'
      ) [8] = ')'
  ; [42] = ';'
  comment [160] = '/**'
  struct_specifier [249] = 'struct Config {'
    struct [96] = 'struct'
    name: type_identifier [362] = 'Config'
    body: field_declaration_list [251] = '{'
      { [64] = '{'
      field_declaration [253] = 'int max_connections;'
        type: primitive_type [93] = 'int'
        declarator: field_identifier [360] = 'max_connections'
        ; [42] = ';'
      comment [160] = '/**< Maximum allowed connections */'
      field_declaration [253] = 'float timeout_seconds;'
        type: primitive_type [93] = 'float'
        declarator: field_identifier [360] = 'timeout_seconds'
        ; [42] = ';'
      comment [160] = '/**< Timeout in seconds */'
      field_declaration [253] = 'const char *host;'
        type_qualifier [243] = 'const'
          const [82] = 'const'
        type: primitive_type [93] = 'char'
        declarator: pointer_declarator [226] = '*host'
          * [26] = '*'
          declarator: field_identifier [360] = 'host'
        ; [42] = ';'
      comment [160] = '/**< Host address */'
      field_declaration [253] = 'int ports[8];'
        type: primitive_type [93] = 'int'
        declarator: array_declarator [236] = 'ports[8]'
          declarator: field_identifier [360] = 'ports'
          [ [70] = '['
          size: number_literal [141] = '8'
          ] [72] = ']'
        ; [42] = ';'
      comment [160] = '/**< Array of port numbers */'
      } [65] = '}'
  ; [42] = ';'
  comment [160] = '// Linkage specification for C++ compatibility'
  preproc_ifdef [170] = '#ifdef __cplusplus'
    #ifdef [12] = '#ifdef'
    name: identifier [1] = '__cplusplus'
    linkage_specification [204] = 'extern "C" {'
      extern [45] = 'extern'
      value: string_literal [320] = '"C"'
        " [152] = '"'
        string_content [153] = 'C'
        " [152] = '"'
      body: declaration_list [213] = '{'
        { [64] = '{'
        preproc_call [168] = '#endif'
          directive: preproc_directive [19] = '#endif'
        comment [160] = '// Function prototypes with documentation'
        comment [160] = '/**'
        declaration [198] = 'int add(int a, int b);'
          type: primitive_type [93] = 'int'
          declarator: function_declarator [230] = 'add(int a, int b)'
            declarator: identifier [1] = 'add'
            parameters: parameter_list [258] = '(int a, int b)'
              ( [5] = '('
              parameter_declaration [260] = 'int a'
                type: primitive_type [93] = 'int'
                declarator: identifier [1] = 'a'
              , [7] = ','
              parameter_declaration [260] = 'int b'
                type: primitive_type [93] = 'int'
                declarator: identifier [1] = 'b'
              ) [8] = ')'
          ; [42] = ';'
        comment [160] = '/**'
        declaration [198] = 'void print_point(const struct Point *p);'
          type: primitive_type [93] = 'void'
          declarator: function_declarator [230] = 'print_point(const struct Point *p)'
            declarator: identifier [1] = 'print_point'
            parameters: parameter_list [258] = '(const struct Point *p)'
              ( [5] = '('
              parameter_declaration [260] = 'const struct Point *p'
                type_qualifier [243] = 'const'
                  const [82] = 'const'
                type: struct_specifier [249] = 'struct Point'
                  struct [96] = 'struct'
                  name: type_identifier [362] = 'Point'
                declarator: pointer_declarator [226] = '*p'
                  * [26] = '*'
                  declarator: identifier [1] = 'p'
              ) [8] = ')'
          ; [42] = ';'
        comment [160] = '/**'
        declaration [198]
          type: type_identifier [362] = 'Rectangle'
          declarator: pointer_declarator [226]
            * [26] = '*'
            declarator: function_declarator [230]
              declarator: identifier [1] = 'create_rectangle'
              parameters: parameter_list [258] = '(int w, int h, struct Point origin)'
                ( [5] = '('
                parameter_declaration [260] = 'int w'
                  type: primitive_type [93] = 'int'
                  declarator: identifier [1] = 'w'
                , [7] = ','
                parameter_declaration [260] = 'int h'
                  type: primitive_type [93] = 'int'
                  declarator: identifier [1] = 'h'
                , [7] = ','
                parameter_declaration [260] = 'struct Point origin'
                  type: struct_specifier [249] = 'struct Point'
                    struct [96] = 'struct'
                    name: type_identifier [362] = 'Point'
                  declarator: identifier [1] = 'origin'
                ) [8] = ')'
          ; [42] = ';'
        comment [160] = '/**'
        declaration [198]
          type: primitive_type [93] = 'int'
          declarator: function_declarator [230]
            declarator: identifier [1] = 'compare_ints'
            parameters: parameter_list [258] = '(const void *a, const void *b)'
              ( [5] = '('
              parameter_declaration [260] = 'const void *a'
                type_qualifier [243] = 'const'
                  const [82] = 'const'
                type: primitive_type [93] = 'void'
                declarator: pointer_declarator [226] = '*a'
                  * [26] = '*'
                  declarator: identifier [1] = 'a'
              , [7] = ','
              parameter_declaration [260] = 'const void *b'
                type_qualifier [243] = 'const'
                  const [82] = 'const'
                type: primitive_type [93] = 'void'
                declarator: pointer_declarator [226] = '*b'
                  * [26] = '*'
                  declarator: identifier [1] = 'b'
              ) [8] = ')'
          ; [42] = ';'
        comment [160] = '/**'
        declaration [198] = 'static inline int is_valid(int value);'
          storage_class_specifier [242] = 'static'
            static [71] = 'static'
          storage_class_specifier [242] = 'inline'
            inline [76] = 'inline'
          type: primitive_type [93] = 'int'
          declarator: function_declarator [230] = 'is_valid(int value)'
            declarator: identifier [1] = 'is_valid'
            parameters: parameter_list [258] = '(int value)'
              ( [5] = '('
              parameter_declaration [260] = 'int value'
                type: primitive_type [93] = 'int'
                declarator: identifier [1] = 'value'
              ) [8] = ')'
          ; [42] = ';'
        comment [160] = '// Global variables with documentation'
        comment [160] = '/**'
        declaration [198] = 'static int global_counter = 0;'
          storage_class_specifier [242] = 'static'
            static [71] = 'static'
          type: primitive_type [93] = 'int'
          declarator: init_declarator [240] = 'global_counter = 0'
            declarator: identifier [1] = 'global_counter'
            = [73] = '='
            value: number_literal [141] = '0'
          ; [42] = ';'
        comment [160] = '/**'
        declaration [198] = 'extern const char *program_name;'
          storage_class_specifier [242] = 'extern'
            extern [45] = 'extern'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'char'
          declarator: pointer_declarator [226] = '*program_name'
            * [26] = '*'
            declarator: identifier [1] = 'program_name'
          ; [42] = ';'
        comment [160] = '/**'
        declaration [198] = 'volatile sig_atomic_t signal_flag = 0;'
          type_qualifier [243] = 'volatile'
            volatile [84] = 'volatile'
          type: type_identifier [362] = 'sig_atomic_t'
          declarator: init_declarator [240] = 'signal_flag = 0'
            declarator: identifier [1] = 'signal_flag'
            = [73] = '='
            value: number_literal [141] = '0'
          ; [42] = ';'
        comment [160] = '// Function definitions with comprehensive documentation'
        comment [160] = '/**'
        function_definition [196] = 'int add(int a, int b) {'
          type: primitive_type [93] = 'int'
          declarator: function_declarator [230] = 'add(int a, int b)'
            declarator: identifier [1] = 'add'
            parameters: parameter_list [258] = '(int a, int b)'
              ( [5] = '('
              parameter_declaration [260] = 'int a'
                type: primitive_type [93] = 'int'
                declarator: identifier [1] = 'a'
              , [7] = ','
              parameter_declaration [260] = 'int b'
                type: primitive_type [93] = 'int'
                declarator: identifier [1] = 'b'
              ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            return_statement [275] = 'return a + b;'
              return [106] = 'return'
              binary_expression [290] = 'a + b'
                left: identifier [1] = 'a'
                operator: + [25] = '+'
                right: identifier [1] = 'b'
              ; [42] = ';'
            } [65] = '}'
        comment [160] = '/**'
        function_definition [196]
          type: primitive_type [93] = 'void'
          declarator: function_declarator [230] = 'print_point(const struct Point *p)'
            declarator: identifier [1] = 'print_point'
            parameters: parameter_list [258] = '(const struct Point *p)'
              ( [5] = '('
              parameter_declaration [260] = 'const struct Point *p'
                type_qualifier [243] = 'const'
                  const [82] = 'const'
                type: struct_specifier [249] = 'struct Point'
                  struct [96] = 'struct'
                  name: type_identifier [362] = 'Point'
                declarator: pointer_declarator [226] = '*p'
                  * [26] = '*'
                  declarator: identifier [1] = 'p'
              ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            if_statement [267] = 'if (p == NULL) {'
              if [98] = 'if'
              condition: parenthesized_expression [312] = '(p == NULL)'
                ( [5] = '('
                binary_expression [290] = 'p == NULL'
                  left: identifier [1] = 'p'
                  operator: == [34] = '=='
                  right: null [321] = 'NULL'
                    NULL [158] = 'NULL'
                ) [8] = ')'
              consequence: compound_statement [241] = '{'
                { [64] = '{'
                expression_statement [266] = 'printf("Point is NULL\n");'
                  call_expression [299] = 'printf("Point is NULL\n")'
                    function: identifier [1] = 'printf'
                    arguments: argument_list [309] = '("Point is NULL\n")'
                      ( [5] = '('
                      string_literal [320] = '"Point is NULL\n"'
                        " [152] = '"'
                        string_content [153] = 'Point is NULL'
                        escape_sequence [154] = '\n'
                        " [152] = '"'
                      ) [8] = ')'
                  ; [42] = ';'
                return_statement [275] = 'return;'
                  return [106] = 'return'
                  ; [42] = ';'
                } [65] = '}'
            expression_statement [266]
              call_expression [299]
                function: identifier [1] = 'printf'
                arguments: argument_list [309]
                  ( [5] = '('
                  string_literal [320] = '"Point: (%.2f, %.2f) - %s\n"'
                    " [152] = '"'
                    string_content [153] = 'Point: (%.2f, %.2f) - %s'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  , [7] = ','
                  field_expression [310] = 'p->x'
                    argument: identifier [1] = 'p'
                    operator: -> [140] = '->'
                    field: field_identifier [360] = 'x'
                  , [7] = ','
                  field_expression [310] = 'p->y'
                    argument: identifier [1] = 'p'
                    operator: -> [140] = '->'
                    field: field_identifier [360] = 'y'
                  , [7] = ','
                  conditional_expression [286] = 'p->label ? p->label : "unnamed"'
                    condition: field_expression [310] = 'p->label'
                      argument: identifier [1] = 'p'
                      operator: -> [140] = '->'
                      field: field_identifier [360] = 'label'
                    ? [114] = '?'
                    consequence: field_expression [310] = 'p->label'
                      argument: identifier [1] = 'p'
                      operator: -> [140] = '->'
                      field: field_identifier [360] = 'label'
                    : [95] = ':'
                    alternative: string_literal [320] = '"unnamed"'
                      " [152] = '"'
                      string_content [153] = 'unnamed'
                      " [152] = '"'
                  ) [8] = ')'
              ; [42] = ';'
            } [65] = '}'
        comment [160] = '/**'
        function_definition [196]
          type: type_identifier [362] = 'Rectangle'
          declarator: pointer_declarator [226]
            * [26] = '*'
            declarator: function_declarator [230]
              declarator: identifier [1] = 'create_rectangle'
              parameters: parameter_list [258] = '(int w, int h, struct Point origin)'
                ( [5] = '('
                parameter_declaration [260] = 'int w'
                  type: primitive_type [93] = 'int'
                  declarator: identifier [1] = 'w'
                , [7] = ','
                parameter_declaration [260] = 'int h'
                  type: primitive_type [93] = 'int'
                  declarator: identifier [1] = 'h'
                , [7] = ','
                parameter_declaration [260] = 'struct Point origin'
                  type: struct_specifier [249] = 'struct Point'
                    struct [96] = 'struct'
                    name: type_identifier [362] = 'Point'
                  declarator: identifier [1] = 'origin'
                ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            declaration [198]
              type: type_identifier [362] = 'Rectangle'
              declarator: init_declarator [240] = '*rect = malloc(sizeof(Rectangle))'
                declarator: pointer_declarator [226] = '*rect'
                  * [26] = '*'
                  declarator: identifier [1] = 'rect'
                = [73] = '='
                value: call_expression [299] = 'malloc(sizeof(Rectangle))'
                  function: identifier [1] = 'malloc'
                  arguments: argument_list [309] = '(sizeof(Rectangle))'
                    ( [5] = '('
                    sizeof_expression [294] = 'sizeof(Rectangle)'
                      sizeof [127] = 'sizeof'
                      value: parenthesized_expression [312] = '(Rectangle)'
                        ( [5] = '('
                        identifier [1] = 'Rectangle'
                        ) [8] = ')'
                    ) [8] = ')'
              ; [42] = ';'
            if_statement [267] = 'if (!rect) {'
              if [98] = 'if'
              condition: parenthesized_expression [312] = '(!rect)'
                ( [5] = '('
                unary_expression [289] = '!rect'
                  operator: ! [22] = '!'
                  argument: identifier [1] = 'rect'
                ) [8] = ')'
              consequence: compound_statement [241] = '{'
                { [64] = '{'
                return_statement [275] = 'return NULL;'
                  return [106] = 'return'
                  null [321] = 'NULL'
                    NULL [158] = 'NULL'
                  ; [42] = ';'
                } [65] = '}'
            expression_statement [266] = 'rect->width = w;'
              assignment_expression [287] = 'rect->width = w'
                left: field_expression [310] = 'rect->width'
                  argument: identifier [1] = 'rect'
                  operator: -> [140] = '->'
                  field: field_identifier [360] = 'width'
                operator: = [73] = '='
                right: identifier [1] = 'w'
              ; [42] = ';'
            expression_statement [266] = 'rect->height = h;'
              assignment_expression [287] = 'rect->height = h'
                left: field_expression [310] = 'rect->height'
                  argument: identifier [1] = 'rect'
                  operator: -> [140] = '->'
                  field: field_identifier [360] = 'height'
                operator: = [73] = '='
                right: identifier [1] = 'h'
              ; [42] = ';'
            expression_statement [266] = 'rect->origin = origin;'
              assignment_expression [287] = 'rect->origin = origin'
                left: field_expression [310] = 'rect->origin'
                  argument: identifier [1] = 'rect'
                  operator: -> [140] = '->'
                  field: field_identifier [360] = 'origin'
                operator: = [73] = '='
                right: identifier [1] = 'origin'
              ; [42] = ';'
            return_statement [275] = 'return rect;'
              return [106] = 'return'
              identifier [1] = 'rect'
              ; [42] = ';'
            } [65] = '}'
        comment [160] = '/**'
        function_definition [196]
          type: primitive_type [93] = 'int'
          declarator: function_declarator [230]
            declarator: identifier [1] = 'compare_ints'
            parameters: parameter_list [258] = '(const void *a, const void *b)'
              ( [5] = '('
              parameter_declaration [260] = 'const void *a'
                type_qualifier [243] = 'const'
                  const [82] = 'const'
                type: primitive_type [93] = 'void'
                declarator: pointer_declarator [226] = '*a'
                  * [26] = '*'
                  declarator: identifier [1] = 'a'
              , [7] = ','
              parameter_declaration [260] = 'const void *b'
                type_qualifier [243] = 'const'
                  const [82] = 'const'
                type: primitive_type [93] = 'void'
                declarator: pointer_declarator [226] = '*b'
                  * [26] = '*'
                  declarator: identifier [1] = 'b'
              ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            declaration [198] = 'int ia = *(const int*)a;'
              type: primitive_type [93] = 'int'
              declarator: init_declarator [240] = 'ia = *(const int*)a'
                declarator: identifier [1] = 'ia'
                = [73] = '='
                value: pointer_expression [288] = '*(const int*)a'
                  operator: * [26] = '*'
                  argument: cast_expression [292] = '(const int*)a'
                    ( [5] = '('
                    type: type_descriptor [293] = 'const int*'
                      type_qualifier [243] = 'const'
                        const [82] = 'const'
                      type: primitive_type [93] = 'int'
                      declarator: abstract_pointer_declarator [229] = '*'
                        * [26] = '*'
                    ) [8] = ')'
                    value: identifier [1] = 'a'
              ; [42] = ';'
            declaration [198] = 'int ib = *(const int*)b;'
              type: primitive_type [93] = 'int'
              declarator: init_declarator [240] = 'ib = *(const int*)b'
                declarator: identifier [1] = 'ib'
                = [73] = '='
                value: pointer_expression [288] = '*(const int*)b'
                  operator: * [26] = '*'
                  argument: cast_expression [292] = '(const int*)b'
                    ( [5] = '('
                    type: type_descriptor [293] = 'const int*'
                      type_qualifier [243] = 'const'
                        const [82] = 'const'
                      type: primitive_type [93] = 'int'
                      declarator: abstract_pointer_declarator [229] = '*'
                        * [26] = '*'
                    ) [8] = ')'
                    value: identifier [1] = 'b'
              ; [42] = ';'
            return_statement [275] = 'return (ia > ib) - (ia < ib);'
              return [106] = 'return'
              binary_expression [290] = '(ia > ib) - (ia < ib)'
                left: parenthesized_expression [312] = '(ia > ib)'
                  ( [5] = '('
                  binary_expression [290] = 'ia > ib'
                    left: identifier [1] = 'ia'
                    operator: > [36] = '>'
                    right: identifier [1] = 'ib'
                  ) [8] = ')'
                operator: - [24] = '-'
                right: parenthesized_expression [312] = '(ia < ib)'
                  ( [5] = '('
                  binary_expression [290] = 'ia < ib'
                    left: identifier [1] = 'ia'
                    operator: < [39] = '<'
                    right: identifier [1] = 'ib'
                  ) [8] = ')'
              ; [42] = ';'
            } [65] = '}'
        comment [160] = '/**'
        function_definition [196] = 'static inline int is_valid(int value) {'
          storage_class_specifier [242] = 'static'
            static [71] = 'static'
          storage_class_specifier [242] = 'inline'
            inline [76] = 'inline'
          type: primitive_type [93] = 'int'
          declarator: function_declarator [230] = 'is_valid(int value)'
            declarator: identifier [1] = 'is_valid'
            parameters: parameter_list [258] = '(int value)'
              ( [5] = '('
              parameter_declaration [260] = 'int value'
                type: primitive_type [93] = 'int'
                declarator: identifier [1] = 'value'
              ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            return_statement [275] = 'return value >= 0 && value < MAX_SIZE;'
              return [106] = 'return'
              binary_expression [290] = 'value >= 0 && value < MAX_SIZE'
                left: binary_expression [290] = 'value >= 0'
                  left: identifier [1] = 'value'
                  operator: >= [37] = '>='
                  right: number_literal [141] = '0'
                operator: && [30] = '&&'
                right: binary_expression [290] = 'value < MAX_SIZE'
                  left: identifier [1] = 'value'
                  operator: < [39] = '<'
                  right: identifier [1] = 'MAX_SIZE'
              ; [42] = ';'
            } [65] = '}'
        comment [160] = '/**'
        function_definition [196] = 'void complex_function(void) {'
          type: primitive_type [93] = 'void'
          declarator: function_declarator [230] = 'complex_function(void)'
            declarator: identifier [1] = 'complex_function'
            parameters: parameter_list [258] = '(void)'
              ( [5] = '('
              parameter_declaration [260] = 'void'
                type: primitive_type [93] = 'void'
              ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            comment [160] = '// Local variable initialization with documentation'
            declaration [198]
              type: primitive_type [93] = 'int'
              declarator: init_declarator [240]
                declarator: array_declarator [236] = 'numbers[10]'
                  declarator: identifier [1] = 'numbers'
                  [ [70] = '['
                  size: number_literal [141] = '10'
                  ] [72] = ']'
                = [73] = '='
                value: initializer_list [313] = '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}'
                  { [64] = '{'
                  number_literal [141] = '1'
                  , [7] = ','
                  number_literal [141] = '2'
                  , [7] = ','
                  number_literal [141] = '3'
                  , [7] = ','
                  number_literal [141] = '4'
                  , [7] = ','
                  number_literal [141] = '5'
                  , [7] = ','
                  number_literal [141] = '6'
                  , [7] = ','
                  number_literal [141] = '7'
                  , [7] = ','
                  number_literal [141] = '8'
                  , [7] = ','
                  number_literal [141] = '9'
                  , [7] = ','
                  number_literal [141] = '10'
                  } [65] = '}'
              ; [42] = ';'
            comment [160] = '/**< Test array for sorting */'
            comment [160] = '/**'
            declaration [198] = 'struct Point points[] = {'
              type: struct_specifier [249] = 'struct Point'
                struct [96] = 'struct'
                name: type_identifier [362] = 'Point'
              declarator: init_declarator [240] = 'points[] = {'
                declarator: array_declarator [236] = 'points[]'
                  declarator: identifier [1] = 'points'
                  [ [70] = '['
                  ] [72] = ']'
                = [73] = '='
                value: initializer_list [313] = '{'
                  { [64] = '{'
                  initializer_list [313] = '{0.0f, 0.0f, "origin"}'
                    { [64] = '{'
                    number_literal [141] = '0.0f'
                    , [7] = ','
                    number_literal [141] = '0.0f'
                    , [7] = ','
                    string_literal [320] = '"origin"'
                      " [152] = '"'
                      string_content [153] = 'origin'
                      " [152] = '"'
                    } [65] = '}'
                  , [7] = ','
                  initializer_list [313] = '{1.0f, 1.0f, "unit"}'
                    { [64] = '{'
                    number_literal [141] = '1.0f'
                    , [7] = ','
                    number_literal [141] = '1.0f'
                    , [7] = ','
                    string_literal [320] = '"unit"'
                      " [152] = '"'
                      string_content [153] = 'unit'
                      " [152] = '"'
                    } [65] = '}'
                  , [7] = ','
                  initializer_list [313] = '{-1.0f, -1.0f, "negative"}'
                    { [64] = '{'
                    number_literal [141] = '-1.0f'
                    , [7] = ','
                    number_literal [141] = '-1.0f'
                    , [7] = ','
                    string_literal [320] = '"negative"'
                      " [152] = '"'
                      string_content [153] = 'negative'
                      " [152] = '"'
                    } [65] = '}'
                  } [65] = '}'
              ; [42] = ';'
            comment [160] = '// Control structure demonstrations with continue statements'
            for_statement [273] = 'for (int i = 0; i < 10; i++) {'
              for [105] = 'for'
              ( [5] = '('
              initializer: declaration [198] = 'int i = 0;'
                type: primitive_type [93] = 'int'
                declarator: init_declarator [240] = 'i = 0'
                  declarator: identifier [1] = 'i'
                  = [73] = '='
                  value: number_literal [141] = '0'
                ; [42] = ';'
              condition: binary_expression [290] = 'i < 10'
                left: identifier [1] = 'i'
                operator: < [39] = '<'
                right: number_literal [141] = '10'
              ; [42] = ';'
              update: update_expression [291] = 'i++'
                argument: identifier [1] = 'i'
                operator: ++ [126] = '++'
              ) [8] = ')'
              body: compound_statement [241] = '{'
                { [64] = '{'
                if_statement [267] = 'if (numbers[i] % 3 == 0) {'
                  if [98] = 'if'
                  condition: parenthesized_expression [312] = '(numbers[i] % 3 == 0)'
                    ( [5] = '('
                    binary_expression [290] = 'numbers[i] % 3 == 0'
                      left: binary_expression [290] = 'numbers[i] % 3'
                        left: subscript_expression [298] = 'numbers[i]'
                          argument: identifier [1] = 'numbers'
                          [ [70] = '['
                          index: identifier [1] = 'i'
                          ] [72] = ']'
                        operator: % [28] = '%'
                        right: number_literal [141] = '3'
                      operator: == [34] = '=='
                      right: number_literal [141] = '0'
                    ) [8] = ')'
                  consequence: compound_statement [241] = '{'
                    { [64] = '{'
                    continue_statement [277] = 'continue;'
                      continue [108] = 'continue'
                      ; [42] = ';'
                    comment [160] = '// Skip multiples of 3'
                    } [65] = '}'
                if_statement [267] = 'if (numbers[i] % 2 == 0) {'
                  if [98] = 'if'
                  condition: parenthesized_expression [312] = '(numbers[i] % 2 == 0)'
                    ( [5] = '('
                    binary_expression [290] = 'numbers[i] % 2 == 0'
                      left: binary_expression [290] = 'numbers[i] % 2'
                        left: subscript_expression [298] = 'numbers[i]'
                          argument: identifier [1] = 'numbers'
                          [ [70] = '['
                          index: identifier [1] = 'i'
                          ] [72] = ']'
                        operator: % [28] = '%'
                        right: number_literal [141] = '2'
                      operator: == [34] = '=='
                      right: number_literal [141] = '0'
                    ) [8] = ')'
                  consequence: compound_statement [241] = '{'
                    { [64] = '{'
                    expression_statement [266]
                      call_expression [299]
                        function: identifier [1] = 'DEBUG_PRINT'
                        arguments: argument_list [309] = '("Even number: %d", numbers[i])'
                          ( [5] = '('
                          string_literal [320] = '"Even number: %d"'
                            " [152] = '"'
                            string_content [153] = 'Even number: %d'
                            " [152] = '"'
                          , [7] = ','
                          subscript_expression [298] = 'numbers[i]'
                            argument: identifier [1] = 'numbers'
                            [ [70] = '['
                            index: identifier [1] = 'i'
                            ] [72] = ']'
                          ) [8] = ')'
                      ; [42] = ';'
                    } [65] = '}'
                  alternative: else_clause [268] = 'else {'
                    else [99] = 'else'
                    compound_statement [241] = '{'
                      { [64] = '{'
                      expression_statement [266]
                        call_expression [299]
                          function: identifier [1] = 'DEBUG_PRINT'
                          arguments: argument_list [309] = '("Odd number: %d", numbers[i])'
                            ( [5] = '('
                            string_literal [320] = '"Odd number: %d"'
                              " [152] = '"'
                              string_content [153] = 'Odd number: %d'
                              " [152] = '"'
                            , [7] = ','
                            subscript_expression [298] = 'numbers[i]'
                              argument: identifier [1] = 'numbers'
                              [ [70] = '['
                              index: identifier [1] = 'i'
                              ] [72] = ']'
                            ) [8] = ')'
                        ; [42] = ';'
                      } [65] = '}'
                } [65] = '}'
            comment [160] = '// Compound literal examples'
            declaration [198]
              type: struct_specifier [249] = 'struct Point'
                struct [96] = 'struct'
                name: type_identifier [362] = 'Point'
              declarator: init_declarator [240]
                declarator: identifier [1] = 'temp_point'
                = [73] = '='
                value: compound_literal_expression [311]
                  ( [5] = '('
                  type: type_descriptor [293] = 'struct Point'
                    type: struct_specifier [249] = 'struct Point'
                      struct [96] = 'struct'
                      name: type_identifier [362] = 'Point'
                  ) [8] = ')'
                  value: initializer_list [313]
                    { [64] = '{'
                    initializer_pair [314] = '.x = 42.0'
                      designator: field_designator [317] = '.x'
                        . [139] = '.'
                        field_identifier [360] = 'x'
                      = [73] = '='
                      value: number_literal [141] = '42.0'
                    , [7] = ','
                    initializer_pair [314] = '.y = 24.0'
                      designator: field_designator [317] = '.y'
                        . [139] = '.'
                        field_identifier [360] = 'y'
                      = [73] = '='
                      value: number_literal [141] = '24.0'
                    , [7] = ','
                    initializer_pair [314] = '.label = "compound"'
                      designator: field_designator [317] = '.label'
                        . [139] = '.'
                        field_identifier [360] = 'label'
                      = [73] = '='
                      value: string_literal [320] = '"compound"'
                        " [152] = '"'
                        string_content [153] = 'compound'
                        " [152] = '"'
                    } [65] = '}'
              ; [42] = ';'
            expression_statement [266] = 'print_point(&temp_point);'
              call_expression [299] = 'print_point(&temp_point)'
                function: identifier [1] = 'print_point'
                arguments: argument_list [309] = '(&temp_point)'
                  ( [5] = '('
                  pointer_expression [288] = '&temp_point'
                    operator: & [33] = '&'
                    argument: identifier [1] = 'temp_point'
                  ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// More compound literals with nested initialization'
            declaration [198] = 'Rectangle temp_rect = (Rectangle){'
              type: type_identifier [362] = 'Rectangle'
              declarator: init_declarator [240] = 'temp_rect = (Rectangle){'
                declarator: identifier [1] = 'temp_rect'
                = [73] = '='
                value: compound_literal_expression [311] = '(Rectangle){'
                  ( [5] = '('
                  type: type_descriptor [293] = 'Rectangle'
                    type: type_identifier [362] = 'Rectangle'
                  ) [8] = ')'
                  value: initializer_list [313] = '{'
                    { [64] = '{'
                    initializer_pair [314] = '.width = 100'
                      designator: field_designator [317] = '.width'
                        . [139] = '.'
                        field_identifier [360] = 'width'
                      = [73] = '='
                      value: number_literal [141] = '100'
                    , [7] = ','
                    initializer_pair [314] = '.height = 50'
                      designator: field_designator [317] = '.height'
                        . [139] = '.'
                        field_identifier [360] = 'height'
                      = [73] = '='
                      value: number_literal [141] = '50'
                    , [7] = ','
                    initializer_pair [314]
                      designator: field_designator [317] = '.origin'
                        . [139] = '.'
                        field_identifier [360] = 'origin'
                      = [73] = '='
                      value: compound_literal_expression [311]
                        ( [5] = '('
                        type: type_descriptor [293] = 'struct Point'
                          type: struct_specifier [249] = 'struct Point'
                            struct [96] = 'struct'
                            name: type_identifier [362] = 'Point'
                        ) [8] = ')'
                        value: initializer_list [313] = '{10.0, 20.0, "rect_origin"}'
                          { [64] = '{'
                          number_literal [141] = '10.0'
                          , [7] = ','
                          number_literal [141] = '20.0'
                          , [7] = ','
                          string_literal [320] = '"rect_origin"'
                            " [152] = '"'
                            string_content [153] = 'rect_origin'
                            " [152] = '"'
                          } [65] = '}'
                    } [65] = '}'
              ; [42] = ';'
            comment [160] = '// Designated initializers for arrays'
            declaration [198] = 'int sparse_array[10] = {'
              type: primitive_type [93] = 'int'
              declarator: init_declarator [240] = 'sparse_array[10] = {'
                declarator: array_declarator [236] = 'sparse_array[10]'
                  declarator: identifier [1] = 'sparse_array'
                  [ [70] = '['
                  size: number_literal [141] = '10'
                  ] [72] = ']'
                = [73] = '='
                value: initializer_list [313] = '{'
                  { [64] = '{'
                  initializer_pair [314] = '[0] = 1'
                    designator: subscript_designator [315] = '[0]'
                      [ [70] = '['
                      number_literal [141] = '0'
                      ] [72] = ']'
                    = [73] = '='
                    value: number_literal [141] = '1'
                  , [7] = ','
                  initializer_pair [314] = '[3] = 4'
                    designator: subscript_designator [315] = '[3]'
                      [ [70] = '['
                      number_literal [141] = '3'
                      ] [72] = ']'
                    = [73] = '='
                    value: number_literal [141] = '4'
                  , [7] = ','
                  initializer_pair [314] = '[7] = 8'
                    designator: subscript_designator [315] = '[7]'
                      [ [70] = '['
                      number_literal [141] = '7'
                      ] [72] = ']'
                    = [73] = '='
                    value: number_literal [141] = '8'
                  , [7] = ','
                  initializer_pair [314] = '[9] = 10'
                    designator: subscript_designator [315] = '[9]'
                      [ [70] = '['
                      number_literal [141] = '9'
                      ] [72] = ']'
                    = [73] = '='
                    value: number_literal [141] = '10'
                  } [65] = '}'
              ; [42] = ';'
            comment [160] = '// Complex designated initializer for struct'
            declaration [198] = 'struct Config default_config = {'
              type: struct_specifier [249] = 'struct Config'
                struct [96] = 'struct'
                name: type_identifier [362] = 'Config'
              declarator: init_declarator [240] = 'default_config = {'
                declarator: identifier [1] = 'default_config'
                = [73] = '='
                value: initializer_list [313] = '{'
                  { [64] = '{'
                  initializer_pair [314] = '.max_connections = 100'
                    designator: field_designator [317] = '.max_connections'
                      . [139] = '.'
                      field_identifier [360] = 'max_connections'
                    = [73] = '='
                    value: number_literal [141] = '100'
                  , [7] = ','
                  initializer_pair [314] = '.timeout_seconds = 30.5f'
                    designator: field_designator [317] = '.timeout_seconds'
                      . [139] = '.'
                      field_identifier [360] = 'timeout_seconds'
                    = [73] = '='
                    value: number_literal [141] = '30.5f'
                  , [7] = ','
                  initializer_pair [314] = '.host = "localhost"'
                    designator: field_designator [317] = '.host'
                      . [139] = '.'
                      field_identifier [360] = 'host'
                    = [73] = '='
                    value: string_literal [320] = '"localhost"'
                      " [152] = '"'
                      string_content [153] = 'localhost'
                      " [152] = '"'
                  , [7] = ','
                  initializer_pair [314] = '.ports = {80, 443, 8080, [7] = 9000}'
                    designator: field_designator [317] = '.ports'
                      . [139] = '.'
                      field_identifier [360] = 'ports'
                    = [73] = '='
                    value: initializer_list [313] = '{80, 443, 8080, [7] = 9000}'
                      { [64] = '{'
                      number_literal [141] = '80'
                      , [7] = ','
                      number_literal [141] = '443'
                      , [7] = ','
                      number_literal [141] = '8080'
                      , [7] = ','
                      initializer_pair [314] = '[7] = 9000'
                        designator: subscript_designator [315] = '[7]'
                          [ [70] = '['
                          number_literal [141] = '7'
                          ] [72] = ']'
                        = [73] = '='
                        value: number_literal [141] = '9000'
                      } [65] = '}'
                  } [65] = '}'
              ; [42] = ';'
            comment [160] = '// Switch statement with comprehensive cases'
            declaration [198] = 'status_t status = STATUS_OK;'
              type: type_identifier [362] = 'status_t'
              declarator: init_declarator [240] = 'status = STATUS_OK'
                declarator: identifier [1] = 'status'
                = [73] = '='
                value: identifier [1] = 'STATUS_OK'
              ; [42] = ';'
            switch_statement [269] = 'switch (status) {'
              switch [100] = 'switch'
              condition: parenthesized_expression [312] = '(status)'
                ( [5] = '('
                identifier [1] = 'status'
                ) [8] = ')'
              body: compound_statement [241] = '{'
                { [64] = '{'
                case_statement [270] = 'case STATUS_OK:'
                  case [101] = 'case'
                  value: identifier [1] = 'STATUS_OK'
                  : [95] = ':'
                  expression_statement [266] = 'printf("Operation successful\n");'
                    call_expression [299] = 'printf("Operation successful\n")'
                      function: identifier [1] = 'printf'
                      arguments: argument_list [309] = '("Operation successful\n")'
                        ( [5] = '('
                        string_literal [320] = '"Operation successful\n"'
                          " [152] = '"'
                          string_content [153] = 'Operation successful'
                          escape_sequence [154] = '\n'
                          " [152] = '"'
                        ) [8] = ')'
                    ; [42] = ';'
                  break_statement [276] = 'break;'
                    break [107] = 'break'
                    ; [42] = ';'
                case_statement [270] = 'case STATUS_ERROR:'
                  case [101] = 'case'
                  value: identifier [1] = 'STATUS_ERROR'
                  : [95] = ':'
                  expression_statement [266] = 'printf("Error occurred\n");'
                    call_expression [299] = 'printf("Error occurred\n")'
                      function: identifier [1] = 'printf'
                      arguments: argument_list [309] = '("Error occurred\n")'
                        ( [5] = '('
                        string_literal [320] = '"Error occurred\n"'
                          " [152] = '"'
                          string_content [153] = 'Error occurred'
                          escape_sequence [154] = '\n'
                          " [152] = '"'
                        ) [8] = ')'
                    ; [42] = ';'
                  break_statement [276] = 'break;'
                    break [107] = 'break'
                    ; [42] = ';'
                case_statement [270] = 'default:'
                  default [102] = 'default'
                  : [95] = ':'
                  expression_statement [266] = 'printf("Unknown status\n");'
                    call_expression [299] = 'printf("Unknown status\n")'
                      function: identifier [1] = 'printf'
                      arguments: argument_list [309] = '("Unknown status\n")'
                        ( [5] = '('
                        string_literal [320] = '"Unknown status\n"'
                          " [152] = '"'
                          string_content [153] = 'Unknown status'
                          escape_sequence [154] = '\n'
                          " [152] = '"'
                        ) [8] = ')'
                    ; [42] = ';'
                  break_statement [276] = 'break;'
                    break [107] = 'break'
                    ; [42] = ';'
                } [65] = '}'
            comment [160] = '// While loop demonstration'
            declaration [198] = 'int count = 0;'
              type: primitive_type [93] = 'int'
              declarator: init_declarator [240] = 'count = 0'
                declarator: identifier [1] = 'count'
                = [73] = '='
                value: number_literal [141] = '0'
              ; [42] = ';'
            while_statement [271] = 'while (count < 3) {'
              while [103] = 'while'
              condition: parenthesized_expression [312] = '(count < 3)'
                ( [5] = '('
                binary_expression [290] = 'count < 3'
                  left: identifier [1] = 'count'
                  operator: < [39] = '<'
                  right: number_literal [141] = '3'
                ) [8] = ')'
              body: compound_statement [241] = '{'
                { [64] = '{'
                expression_statement [266] = 'print_point(&points[count]);'
                  call_expression [299] = 'print_point(&points[count])'
                    function: identifier [1] = 'print_point'
                    arguments: argument_list [309] = '(&points[count])'
                      ( [5] = '('
                      pointer_expression [288] = '&points[count]'
                        operator: & [33] = '&'
                        argument: subscript_expression [298] = 'points[count]'
                          argument: identifier [1] = 'points'
                          [ [70] = '['
                          index: identifier [1] = 'count'
                          ] [72] = ']'
                      ) [8] = ')'
                  ; [42] = ';'
                expression_statement [266] = 'count++;'
                  update_expression [291] = 'count++'
                    argument: identifier [1] = 'count'
                    operator: ++ [126] = '++'
                  ; [42] = ';'
                } [65] = '}'
            comment [160] = '// Do-while loop for guaranteed execution'
            declaration [198] = 'int j = 0;'
              type: primitive_type [93] = 'int'
              declarator: init_declarator [240] = 'j = 0'
                declarator: identifier [1] = 'j'
                = [73] = '='
                value: number_literal [141] = '0'
              ; [42] = ';'
            do_statement [272] = 'do {'
              do [104] = 'do'
              body: compound_statement [241] = '{'
                { [64] = '{'
                expression_statement [266] = 'printf("Value: %d\n", SQUARE(j));'
                  call_expression [299] = 'printf("Value: %d\n", SQUARE(j))'
                    function: identifier [1] = 'printf'
                    arguments: argument_list [309] = '("Value: %d\n", SQUARE(j))'
                      ( [5] = '('
                      string_literal [320] = '"Value: %d\n"'
                        " [152] = '"'
                        string_content [153] = 'Value: %d'
                        escape_sequence [154] = '\n'
                        " [152] = '"'
                      , [7] = ','
                      call_expression [299] = 'SQUARE(j)'
                        function: identifier [1] = 'SQUARE'
                        arguments: argument_list [309] = '(j)'
                          ( [5] = '('
                          identifier [1] = 'j'
                          ) [8] = ')'
                      ) [8] = ')'
                  ; [42] = ';'
                expression_statement [266] = 'j++;'
                  update_expression [291] = 'j++'
                    argument: identifier [1] = 'j'
                    operator: ++ [126] = '++'
                  ; [42] = ';'
                } [65] = '}'
              while [103] = 'while'
              condition: parenthesized_expression [312] = '(j < 3)'
                ( [5] = '('
                binary_expression [290] = 'j < 3'
                  left: identifier [1] = 'j'
                  operator: < [39] = '<'
                  right: number_literal [141] = '3'
                ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// Goto statement for cleanup patterns'
            if_statement [267] = 'if (global_counter > 100) {'
              if [98] = 'if'
              condition: parenthesized_expression [312] = '(global_counter > 100)'
                ( [5] = '('
                binary_expression [290] = 'global_counter > 100'
                  left: identifier [1] = 'global_counter'
                  operator: > [36] = '>'
                  right: number_literal [141] = '100'
                ) [8] = ')'
              consequence: compound_statement [241] = '{'
                { [64] = '{'
                goto_statement [278] = 'goto cleanup;'
                  goto [109] = 'goto'
                  label: statement_identifier [361] = 'cleanup'
                  ; [42] = ';'
                } [65] = '}'
            comment [160] = '// Function pointer demonstration'
            declaration [198] = 'compare_fn cmp = compare_ints;'
              type: type_identifier [362] = 'compare_fn'
              declarator: init_declarator [240] = 'cmp = compare_ints'
                declarator: identifier [1] = 'cmp'
                = [73] = '='
                value: identifier [1] = 'compare_ints'
              ; [42] = ';'
            expression_statement [266] = 'qsort(numbers, 10, sizeof(int), cmp);'
              call_expression [299] = 'qsort(numbers, 10, sizeof(int), cmp)'
                function: identifier [1] = 'qsort'
                arguments: argument_list [309] = '(numbers, 10, sizeof(int), cmp)'
                  ( [5] = '('
                  identifier [1] = 'numbers'
                  , [7] = ','
                  number_literal [141] = '10'
                  , [7] = ','
                  sizeof_expression [294] = 'sizeof(int)'
                    sizeof [127] = 'sizeof'
                    ( [5] = '('
                    type: type_descriptor [293] = 'int'
                      type: primitive_type [93] = 'int'
                    ) [8] = ')'
                  , [7] = ','
                  identifier [1] = 'cmp'
                  ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// Union usage demonstration'
            declaration [198] = 'union Value val;'
              type: union_specifier [250] = 'union Value'
                union [97] = 'union'
                name: type_identifier [362] = 'Value'
              declarator: identifier [1] = 'val'
              ; [42] = ';'
            expression_statement [266] = 'val.i = 42;'
              assignment_expression [287] = 'val.i = 42'
                left: field_expression [310] = 'val.i'
                  argument: identifier [1] = 'val'
                  operator: . [139] = '.'
                  field: field_identifier [360] = 'i'
                operator: = [73] = '='
                right: number_literal [141] = '42'
              ; [42] = ';'
            expression_statement [266] = 'printf("Integer value: %d\n", val.i);'
              call_expression [299] = 'printf("Integer value: %d\n", val.i)'
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("Integer value: %d\n", val.i)'
                  ( [5] = '('
                  string_literal [320] = '"Integer value: %d\n"'
                    " [152] = '"'
                    string_content [153] = 'Integer value: %d'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  , [7] = ','
                  field_expression [310] = 'val.i'
                    argument: identifier [1] = 'val'
                    operator: . [139] = '.'
                    field: field_identifier [360] = 'i'
                  ) [8] = ')'
              ; [42] = ';'
            expression_statement [266] = 'val.f = 3.14f;'
              assignment_expression [287] = 'val.f = 3.14f'
                left: field_expression [310] = 'val.f'
                  argument: identifier [1] = 'val'
                  operator: . [139] = '.'
                  field: field_identifier [360] = 'f'
                operator: = [73] = '='
                right: number_literal [141] = '3.14f'
              ; [42] = ';'
            expression_statement [266] = 'printf("Float value: %.2f\n", val.f);'
              call_expression [299] = 'printf("Float value: %.2f\n", val.f)'
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("Float value: %.2f\n", val.f)'
                  ( [5] = '('
                  string_literal [320] = '"Float value: %.2f\n"'
                    " [152] = '"'
                    string_content [153] = 'Float value: %.2f'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  , [7] = ','
                  field_expression [310] = 'val.f'
                    argument: identifier [1] = 'val'
                    operator: . [139] = '.'
                    field: field_identifier [360] = 'f'
                  ) [8] = ')'
              ; [42] = ';'
            labeled_statement [264] = 'cleanup:'
              label: statement_identifier [361] = 'cleanup'
              : [95] = ':'
              expression_statement [266] = 'printf("Cleanup completed\n");'
                call_expression [299] = 'printf("Cleanup completed\n")'
                  function: identifier [1] = 'printf'
                  arguments: argument_list [309] = '("Cleanup completed\n")'
                    ( [5] = '('
                    string_literal [320] = '"Cleanup completed\n"'
                      " [152] = '"'
                      string_content [153] = 'Cleanup completed'
                      escape_sequence [154] = '\n'
                      " [152] = '"'
                    ) [8] = ')'
                ; [42] = ';'
            } [65] = '}'
        comment [160] = '/**'
        function_definition [196]
          type: primitive_type [93] = 'void'
          declarator: function_declarator [230] = 'debug_log(const char *format, ...)'
            declarator: identifier [1] = 'debug_log'
            parameters: parameter_list [258] = '(const char *format, ...)'
              ( [5] = '('
              parameter_declaration [260] = 'const char *format'
                type_qualifier [243] = 'const'
                  const [82] = 'const'
                type: primitive_type [93] = 'char'
                declarator: pointer_declarator [226] = '*format'
                  * [26] = '*'
                  declarator: identifier [1] = 'format'
              , [7] = ','
              variadic_parameter [257] = '...'
                ... [6] = '...'
              ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            declaration [198] = 'va_list args;'
              type: type_identifier [362] = 'va_list'
              declarator: identifier [1] = 'args'
              ; [42] = ';'
            expression_statement [266] = 'va_start(args, format);'
              call_expression [299] = 'va_start(args, format)'
                function: identifier [1] = 'va_start'
                arguments: argument_list [309] = '(args, format)'
                  ( [5] = '('
                  identifier [1] = 'args'
                  , [7] = ','
                  identifier [1] = 'format'
                  ) [8] = ')'
              ; [42] = ';'
            expression_statement [266] = 'vprintf(format, args);'
              call_expression [299] = 'vprintf(format, args)'
                function: identifier [1] = 'vprintf'
                arguments: argument_list [309] = '(format, args)'
                  ( [5] = '('
                  identifier [1] = 'format'
                  , [7] = ','
                  identifier [1] = 'args'
                  ) [8] = ')'
              ; [42] = ';'
            expression_statement [266] = 'va_end(args);'
              call_expression [299] = 'va_end(args)'
                function: identifier [1] = 'va_end'
                arguments: argument_list [309] = '(args)'
                  ( [5] = '('
                  identifier [1] = 'args'
                  ) [8] = ')'
              ; [42] = ';'
            expression_statement [266] = 'printf("\n");'
              call_expression [299] = 'printf("\n")'
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("\n")'
                  ( [5] = '('
                  string_literal [320] = '"\n"'
                    " [152] = '"'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  ) [8] = ')'
              ; [42] = ';'
            } [65] = '}'
        comment [160] = '/**'
        function_definition [196] = 'uint32_t reverse_bits(uint32_t num) {'
          type: primitive_type [93] = 'uint32_t'
          declarator: function_declarator [230] = 'reverse_bits(uint32_t num)'
            declarator: identifier [1] = 'reverse_bits'
            parameters: parameter_list [258] = '(uint32_t num)'
              ( [5] = '('
              parameter_declaration [260] = 'uint32_t num'
                type: primitive_type [93] = 'uint32_t'
                declarator: identifier [1] = 'num'
              ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            declaration [198] = 'uint32_t result = 0;'
              type: primitive_type [93] = 'uint32_t'
              declarator: init_declarator [240] = 'result = 0'
                declarator: identifier [1] = 'result'
                = [73] = '='
                value: number_literal [141] = '0'
              ; [42] = ';'
            for_statement [273] = 'for (int i = 0; i < 32; i++) {'
              for [105] = 'for'
              ( [5] = '('
              initializer: declaration [198] = 'int i = 0;'
                type: primitive_type [93] = 'int'
                declarator: init_declarator [240] = 'i = 0'
                  declarator: identifier [1] = 'i'
                  = [73] = '='
                  value: number_literal [141] = '0'
                ; [42] = ';'
              condition: binary_expression [290] = 'i < 32'
                left: identifier [1] = 'i'
                operator: < [39] = '<'
                right: number_literal [141] = '32'
              ; [42] = ';'
              update: update_expression [291] = 'i++'
                argument: identifier [1] = 'i'
                operator: ++ [126] = '++'
              ) [8] = ')'
              body: compound_statement [241] = '{'
                { [64] = '{'
                if_statement [267] = 'if (num & (1U << i)) {'
                  if [98] = 'if'
                  condition: parenthesized_expression [312] = '(num & (1U << i))'
                    ( [5] = '('
                    binary_expression [290] = 'num & (1U << i)'
                      left: identifier [1] = 'num'
                      operator: & [33] = '&'
                      right: parenthesized_expression [312] = '(1U << i)'
                        ( [5] = '('
                        binary_expression [290] = '1U << i'
                          left: number_literal [141] = '1U'
                          operator: << [40] = '<<'
                          right: identifier [1] = 'i'
                        ) [8] = ')'
                    ) [8] = ')'
                  consequence: compound_statement [241] = '{'
                    { [64] = '{'
                    expression_statement [266] = 'result |= (1U << (31 - i));'
                      assignment_expression [287] = 'result |= (1U << (31 - i))'
                        left: identifier [1] = 'result'
                        operator: |= [124] = '|='
                        right: parenthesized_expression [312] = '(1U << (31 - i))'
                          ( [5] = '('
                          binary_expression [290] = '1U << (31 - i)'
                            left: number_literal [141] = '1U'
                            operator: << [40] = '<<'
                            right: parenthesized_expression [312] = '(31 - i)'
                              ( [5] = '('
                              binary_expression [290] = '31 - i'
                                left: number_literal [141] = '31'
                                operator: - [24] = '-'
                                right: identifier [1] = 'i'
                              ) [8] = ')'
                          ) [8] = ')'
                      ; [42] = ';'
                    } [65] = '}'
                } [65] = '}'
            return_statement [275] = 'return result;'
              return [106] = 'return'
              identifier [1] = 'result'
              ; [42] = ';'
            } [65] = '}'
        comment [160] = '/**'
        function_definition [196] = 'int main(int argc, char *argv[]) {'
          type: primitive_type [93] = 'int'
          declarator: function_declarator [230] = 'main(int argc, char *argv[])'
            declarator: identifier [1] = 'main'
            parameters: parameter_list [258] = '(int argc, char *argv[])'
              ( [5] = '('
              parameter_declaration [260] = 'int argc'
                type: primitive_type [93] = 'int'
                declarator: identifier [1] = 'argc'
              , [7] = ','
              parameter_declaration [260] = 'char *argv[]'
                type: primitive_type [93] = 'char'
                declarator: pointer_declarator [226] = '*argv[]'
                  * [26] = '*'
                  declarator: array_declarator [236] = 'argv[]'
                    declarator: identifier [1] = 'argv'
                    [ [70] = '['
                    ] [72] = ']'
              ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            expression_statement [266] = 'printf("C Comprehensive Example\n");'
              call_expression [299] = 'printf("C Comprehensive Example\n")'
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("C Comprehensive Example\n")'
                  ( [5] = '('
                  string_literal [320] = '"C Comprehensive Example\n"'
                    " [152] = '"'
                    string_content [153] = 'C Comprehensive Example'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  ) [8] = ')'
              ; [42] = ';'
            expression_statement [266] = 'printf("Arguments: %d\n", argc);'
              call_expression [299] = 'printf("Arguments: %d\n", argc)'
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("Arguments: %d\n", argc)'
                  ( [5] = '('
                  string_literal [320] = '"Arguments: %d\n"'
                    " [152] = '"'
                    string_content [153] = 'Arguments: %d'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  , [7] = ','
                  identifier [1] = 'argc'
                  ) [8] = ')'
              ; [42] = ';'
            if_statement [267] = 'if (argc > 1) {'
              if [98] = 'if'
              condition: parenthesized_expression [312] = '(argc > 1)'
                ( [5] = '('
                binary_expression [290] = 'argc > 1'
                  left: identifier [1] = 'argc'
                  operator: > [36] = '>'
                  right: number_literal [141] = '1'
                ) [8] = ')'
              consequence: compound_statement [241] = '{'
                { [64] = '{'
                expression_statement [266] = 'printf("First argument: %s\n", argv[1]);'
                  call_expression [299] = 'printf("First argument: %s\n", argv[1])'
                    function: identifier [1] = 'printf'
                    arguments: argument_list [309] = '("First argument: %s\n", argv[1])'
                      ( [5] = '('
                      string_literal [320] = '"First argument: %s\n"'
                        " [152] = '"'
                        string_content [153] = 'First argument: %s'
                        escape_sequence [154] = '\n'
                        " [152] = '"'
                      , [7] = ','
                      subscript_expression [298] = 'argv[1]'
                        argument: identifier [1] = 'argv'
                        [ [70] = '['
                        index: number_literal [141] = '1'
                        ] [72] = ']'
                      ) [8] = ')'
                  ; [42] = ';'
                } [65] = '}'
            comment [160] = '// Test basic arithmetic operations'
            declaration [198] = 'int sum = add(5, 3);'
              type: primitive_type [93] = 'int'
              declarator: init_declarator [240] = 'sum = add(5, 3)'
                declarator: identifier [1] = 'sum'
                = [73] = '='
                value: call_expression [299] = 'add(5, 3)'
                  function: identifier [1] = 'add'
                  arguments: argument_list [309] = '(5, 3)'
                    ( [5] = '('
                    number_literal [141] = '5'
                    , [7] = ','
                    number_literal [141] = '3'
                    ) [8] = ')'
              ; [42] = ';'
            expression_statement [266] = 'printf("Sum: %d\n", sum);'
              call_expression [299] = 'printf("Sum: %d\n", sum)'
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("Sum: %d\n", sum)'
                  ( [5] = '('
                  string_literal [320] = '"Sum: %d\n"'
                    " [152] = '"'
                    string_content [153] = 'Sum: %d'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  , [7] = ','
                  identifier [1] = 'sum'
                  ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// Test structure usage and pointer operations'
            declaration [198]
              type: struct_specifier [249] = 'struct Point'
                struct [96] = 'struct'
                name: type_identifier [362] = 'Point'
              declarator: init_declarator [240] = 'p = {10.5f, 20.3f, "test point"}'
                declarator: identifier [1] = 'p'
                = [73] = '='
                value: initializer_list [313] = '{10.5f, 20.3f, "test point"}'
                  { [64] = '{'
                  number_literal [141] = '10.5f'
                  , [7] = ','
                  number_literal [141] = '20.3f'
                  , [7] = ','
                  string_literal [320] = '"test point"'
                    " [152] = '"'
                    string_content [153] = 'test point'
                    " [152] = '"'
                  } [65] = '}'
              ; [42] = ';'
            expression_statement [266] = 'print_point(&p);'
              call_expression [299] = 'print_point(&p)'
                function: identifier [1] = 'print_point'
                arguments: argument_list [309] = '(&p)'
                  ( [5] = '('
                  pointer_expression [288] = '&p'
                    operator: & [33] = '&'
                    argument: identifier [1] = 'p'
                  ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// Test dynamic memory allocation and management'
            declaration [198]
              type: type_identifier [362] = 'Rectangle'
              declarator: init_declarator [240] = '*rect = create_rectangle(100, 200, p)'
                declarator: pointer_declarator [226] = '*rect'
                  * [26] = '*'
                  declarator: identifier [1] = 'rect'
                = [73] = '='
                value: call_expression [299] = 'create_rectangle(100, 200, p)'
                  function: identifier [1] = 'create_rectangle'
                  arguments: argument_list [309] = '(100, 200, p)'
                    ( [5] = '('
                    number_literal [141] = '100'
                    , [7] = ','
                    number_literal [141] = '200'
                    , [7] = ','
                    identifier [1] = 'p'
                    ) [8] = ')'
              ; [42] = ';'
            if_statement [267] = 'if (rect) {'
              if [98] = 'if'
              condition: parenthesized_expression [312] = '(rect)'
                ( [5] = '('
                identifier [1] = 'rect'
                ) [8] = ')'
              consequence: compound_statement [241] = '{'
                { [64] = '{'
                expression_statement [266]
                  call_expression [299]
                    function: identifier [1] = 'printf'
                    arguments: argument_list [309] = '("Rectangle: %dx%d at (%.1f, %.1f)\n", '
                      ( [5] = '('
                      string_literal [320] = '"Rectangle: %dx%d at (%.1f, %.1f)\n"'
                        " [152] = '"'
                        string_content [153] = 'Rectangle: %dx%d at (%.1f, %.1f)'
                        escape_sequence [154] = '\n'
                        " [152] = '"'
                      , [7] = ','
                      field_expression [310] = 'rect->width'
                        argument: identifier [1] = 'rect'
                        operator: -> [140] = '->'
                        field: field_identifier [360] = 'width'
                      , [7] = ','
                      field_expression [310] = 'rect->height'
                        argument: identifier [1] = 'rect'
                        operator: -> [140] = '->'
                        field: field_identifier [360] = 'height'
                      , [7] = ','
                      field_expression [310] = 'rect->origin.x'
                        argument: field_expression [310] = 'rect->origin'
                          argument: identifier [1] = 'rect'
                          operator: -> [140] = '->'
                          field: field_identifier [360] = 'origin'
                        operator: . [139] = '.'
                        field: field_identifier [360] = 'x'
                      , [7] = ','
                      field_expression [310] = 'rect->origin.y'
                        argument: field_expression [310] = 'rect->origin'
                          argument: identifier [1] = 'rect'
                          operator: -> [140] = '->'
                          field: field_identifier [360] = 'origin'
                        operator: . [139] = '.'
                        field: field_identifier [360] = 'y'
                      ) [8] = ')'
                  ; [42] = ';'
                expression_statement [266] = 'free(rect);'
                  call_expression [299] = 'free(rect)'
                    function: identifier [1] = 'free'
                    arguments: argument_list [309] = '(rect)'
                      ( [5] = '('
                      identifier [1] = 'rect'
                      ) [8] = ')'
                  ; [42] = ';'
                comment [160] = '// Proper memory cleanup'
                } [65] = '}'
            comment [160] = '// Test complex language features'
            expression_statement [266] = 'complex_function();'
              call_expression [299] = 'complex_function()'
                function: identifier [1] = 'complex_function'
                arguments: argument_list [309] = '()'
                  ( [5] = '('
                  ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// Test bit manipulation algorithms'
            declaration [198] = 'uint32_t original = 0x12345678;'
              type: primitive_type [93] = 'uint32_t'
              declarator: init_declarator [240] = 'original = 0x12345678'
                declarator: identifier [1] = 'original'
                = [73] = '='
                value: number_literal [141] = '0x12345678'
              ; [42] = ';'
            declaration [198]
              type: primitive_type [93] = 'uint32_t'
              declarator: init_declarator [240] = 'reversed = reverse_bits(original)'
                declarator: identifier [1] = 'reversed'
                = [73] = '='
                value: call_expression [299] = 'reverse_bits(original)'
                  function: identifier [1] = 'reverse_bits'
                  arguments: argument_list [309] = '(original)'
                    ( [5] = '('
                    identifier [1] = 'original'
                    ) [8] = ')'
              ; [42] = ';'
            expression_statement [266]
              call_expression [299]
                function: identifier [1] = 'printf'
                arguments: argument_list [309]
                  ( [5] = '('
                  string_literal [320] = '"Original: 0x%08X, Reversed: 0x%08X\n"'
                    " [152] = '"'
                    string_content [153] = 'Original: 0x%08X, Reversed: 0x%08X'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  , [7] = ','
                  identifier [1] = 'original'
                  , [7] = ','
                  identifier [1] = 'reversed'
                  ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// Test variadic function capabilities'
            expression_statement [266]
              call_expression [299]
                function: identifier [1] = 'debug_log'
                arguments: argument_list [309]
                  ( [5] = '('
                  string_literal [320]
                    " [152] = '"'
                    string_content [153] = 'Debug message with values: %d, %s, %.2f'
                    " [152] = '"'
                  , [7] = ','
                  number_literal [141] = '42'
                  , [7] = ','
                  string_literal [320] = '"hello"'
                    " [152] = '"'
                    string_content [153] = 'hello'
                    " [152] = '"'
                  , [7] = ','
                  number_literal [141] = '3.14'
                  ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// Preprocessor function-like macro calls'
            declaration [198] = 'int concat_result = CONCAT(12, 34);'
              type: primitive_type [93] = 'int'
              declarator: init_declarator [240] = 'concat_result = CONCAT(12, 34)'
                declarator: identifier [1] = 'concat_result'
                = [73] = '='
                value: call_expression [299] = 'CONCAT(12, 34)'
                  function: identifier [1] = 'CONCAT'
                  arguments: argument_list [309] = '(12, 34)'
                    ( [5] = '('
                    number_literal [141] = '12'
                    , [7] = ','
                    number_literal [141] = '34'
                    ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// Results in 1234'
            declaration [198]
              type_qualifier [243] = 'const'
                const [82] = 'const'
              type: primitive_type [93] = 'char'
              declarator: init_declarator [240] = '*stringified = STRINGIFY(MAX_SIZE)'
                declarator: pointer_declarator [226] = '*stringified'
                  * [26] = '*'
                  declarator: identifier [1] = 'stringified'
                = [73] = '='
                value: call_expression [299] = 'STRINGIFY(MAX_SIZE)'
                  function: identifier [1] = 'STRINGIFY'
                  arguments: argument_list [309] = '(MAX_SIZE)'
                    ( [5] = '('
                    identifier [1] = 'MAX_SIZE'
                    ) [8] = ')'
              ; [42] = ';'
            comment [160] = '// Results in "1024"'
            preproc_ifdef [170] = '#ifdef DEBUG_BUILD'
              #ifdef [12] = '#ifdef'
              name: identifier [1] = 'DEBUG_BUILD'
              expression_statement [266] = 'LOG("Debug build detected");'
                call_expression [299] = 'LOG("Debug build detected")'
                  function: identifier [1] = 'LOG'
                  arguments: argument_list [309] = '("Debug build detected")'
                    ( [5] = '('
                    string_literal [320] = '"Debug build detected"'
                      " [152] = '"'
                      string_content [153] = 'Debug build detected'
                      " [152] = '"'
                    ) [8] = ')'
                ; [42] = ';'
              #endif [11] = '#endif'
            comment [160] = '// Use preprocessor defined checks'
            preproc_if [169]
              #if [9] = '#if'
              condition: call_expression [299] = 'IS_DEFINED(ADVANCED_FEATURES_AVAILABLE)'
                function: identifier [1] = 'IS_DEFINED'
                arguments: argument_list [309] = '(ADVANCED_FEATURES_AVAILABLE)'
                  ( [5] = '('
                  identifier [1] = 'ADVANCED_FEATURES_AVAILABLE'
                  ) [8] = ')'
              
 [10] = ''
              expression_statement [266]
                call_expression [299]
                  function: identifier [1] = 'printf'
                  arguments: argument_list [309] = '("Advanced features are available\n")'
                    ( [5] = '('
                    string_literal [320] = '"Advanced features are available\n"'
                      " [152] = '"'
                      string_content [153] = 'Advanced features are available'
                      escape_sequence [154] = '\n'
                      " [152] = '"'
                    ) [8] = ')'
                ; [42] = ';'
              #endif [11] = '#endif'
            return_statement [275] = 'return EXIT_SUCCESS;'
              return [106] = 'return'
              identifier [1] = 'EXIT_SUCCESS'
              ; [42] = ';'
            } [65] = '}'
        comment [160] = '/**'
        function_definition [196] = 'static void helper_function(void) {'
          storage_class_specifier [242] = 'static'
            static [71] = 'static'
          type: primitive_type [93] = 'void'
          declarator: function_declarator [230] = 'helper_function(void)'
            declarator: identifier [1] = 'helper_function'
            parameters: parameter_list [258] = '(void)'
              ( [5] = '('
              parameter_declaration [260] = 'void'
                type: primitive_type [93] = 'void'
              ) [8] = ')'
          body: compound_statement [241] = '{'
            { [64] = '{'
            declaration [198] = 'static int call_count = 0;'
              storage_class_specifier [242] = 'static'
                static [71] = 'static'
              type: primitive_type [93] = 'int'
              declarator: init_declarator [240] = 'call_count = 0'
                declarator: identifier [1] = 'call_count'
                = [73] = '='
                value: number_literal [141] = '0'
              ; [42] = ';'
            comment [160] = '/**< Static counter preserves state */'
            expression_statement [266] = 'call_count++;'
              update_expression [291] = 'call_count++'
                argument: identifier [1] = 'call_count'
                operator: ++ [126] = '++'
              ; [42] = ';'
            expression_statement [266]
              call_expression [299]
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("Helper called %d times\n", call_count)'
                  ( [5] = '('
                  string_literal [320] = '"Helper called %d times\n"'
                    " [152] = '"'
                    string_content [153] = 'Helper called %d times'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  , [7] = ','
                  identifier [1] = 'call_count'
                  ) [8] = ')'
              ; [42] = ';'
            } [65] = '}'
        comment [160] = '// Close linkage specification'
        preproc_ifdef [170] = '#ifdef __cplusplus'
          #ifdef [12] = '#ifdef'
          name: identifier [1] = '__cplusplus'
          #endif [11] = ''
        } [65] = '}'
    #endif [11] = '#endif'
```

## Node Type Statistics

| Node Type | Count | Max Depth |
|-----------|-------|----------|
| 
 | 3 | 7 |
| ! | 1 | 9 |
| " | 64 | 15 |
| #define | 14 | 6 |
| #elif | 1 | 4 |
| #else | 2 | 5 |
| #endif | 7 | 7 |
| #if | 2 | 7 |
| #ifdef | 5 | 7 |
| #include | 6 | 2 |
| % | 2 | 12 |
| & | 4 | 12 |
| && | 1 | 8 |
| ( | 96 | 15 |
| ) | 96 | 15 |
| * | 26 | 12 |
| + | 1 | 8 |
| ++ | 5 | 10 |
| , | 79 | 14 |
| - | 2 | 16 |
| -> | 11 | 13 |
| . | 16 | 12 |
| ... | 2 | 8 |
| : | 5 | 10 |
| ; | 121 | 12 |
| < | 6 | 10 |
| << | 2 | 14 |
| = | 49 | 12 |
| == | 3 | 11 |
| > | 3 | 10 |
| >= | 1 | 9 |
| ? | 1 | 10 |
| NULL | 2 | 10 |
| [ | 18 | 15 |
| ] | 18 | 15 |
| __attribute__ | 2 | 3 |
| abstract_pointer_declarator | 4 | 11 |
| argument_list | 42 | 13 |
| array_declarator | 7 | 9 |
| assignment_expression | 6 | 11 |
| attribute_specifier | 2 | 2 |
| binary_expression | 23 | 15 |
| break | 3 | 10 |
| break_statement | 3 | 9 |
| call_expression | 40 | 12 |
| case | 2 | 9 |
| case_statement | 3 | 8 |
| cast_expression | 2 | 9 |
| comment | 89 | 10 |
| compound_literal_expression | 3 | 11 |
| compound_statement | 24 | 10 |
| conditional_expression | 1 | 9 |
| const | 15 | 12 |
| continue | 1 | 11 |
| continue_statement | 1 | 10 |
| declaration | 34 | 7 |
| declaration_list | 1 | 3 |
| default | 1 | 9 |
| defined | 3 | 5 |
| do | 1 | 7 |
| do_statement | 1 | 6 |
| else | 1 | 10 |
| else_clause | 1 | 9 |
| enum | 1 | 3 |
| enum_specifier | 1 | 2 |
| enumerator | 3 | 4 |
| enumerator_list | 1 | 3 |
| escape_sequence | 18 | 13 |
| expression_statement | 40 | 11 |
| extern | 2 | 6 |
| field_declaration | 20 | 4 |
| field_declaration_list | 6 | 3 |
| field_designator | 10 | 11 |
| field_expression | 17 | 12 |
| field_identifier | 47 | 13 |
| for | 2 | 7 |
| for_statement | 2 | 6 |
| function_declarator | 16 | 6 |
| function_definition | 10 | 4 |
| goto | 1 | 9 |
| goto_statement | 1 | 8 |
| identifier | 227 | 16 |
| if | 8 | 9 |
| if_statement | 8 | 8 |
| init_declarator | 26 | 8 |
| initializer_list | 12 | 12 |
| initializer_pair | 15 | 11 |
| inline | 2 | 6 |
| labeled_statement | 1 | 6 |
| linkage_specification | 1 | 2 |
| null | 2 | 9 |
| number_literal | 83 | 16 |
| parameter_declaration | 26 | 8 |
| parameter_list | 16 | 7 |
| parenthesized_declarator | 1 | 3 |
| parenthesized_expression | 17 | 14 |
| pointer_declarator | 20 | 8 |
| pointer_expression | 5 | 11 |
| preproc_arg | 12 | 6 |
| preproc_call | 1 | 4 |
| preproc_def | 7 | 5 |
| preproc_defined | 3 | 4 |
| preproc_directive | 1 | 5 |
| preproc_elif | 1 | 3 |
| preproc_else | 2 | 4 |
| preproc_function_def | 7 | 3 |
| preproc_if | 2 | 6 |
| preproc_ifdef | 5 | 6 |
| preproc_include | 6 | 1 |
| preproc_params | 7 | 4 |
| primitive_type | 74 | 11 |
| return | 8 | 9 |
| return_statement | 8 | 8 |
| sizeof | 2 | 11 |
| sizeof_expression | 2 | 10 |
| statement_identifier | 2 | 9 |
| static | 5 | 8 |
| storage_class_specifier | 8 | 7 |
| string_content | 31 | 15 |
| string_literal | 32 | 14 |
| struct | 20 | 14 |
| struct_specifier | 20 | 13 |
| subscript_designator | 5 | 12 |
| subscript_expression | 6 | 14 |
| switch | 1 | 7 |
| switch_statement | 1 | 6 |
| system_lib_string | 6 | 2 |
| translation_unit | 1 | 0 |
| type_definition | 5 | 1 |
| type_descriptor | 6 | 12 |
| type_identifier | 36 | 14 |
| type_qualifier | 16 | 11 |
| typedef | 5 | 2 |
| unary_expression | 1 | 8 |
| union | 2 | 8 |
| union_specifier | 2 | 7 |
| update_expression | 5 | 9 |
| variadic_parameter | 1 | 7 |
| volatile | 1 | 6 |
| while | 2 | 7 |
| while_statement | 1 | 6 |
| { | 44 | 13 |
| |= | 1 | 12 |
| || | 1 | 3 |
| } | 44 | 13 |

**Total unique node types**: 145
