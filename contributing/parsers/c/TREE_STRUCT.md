# C AST Tree Structure

Complete nested structure from comprehensive.c

```
translation_unit [161] = '/**'
  comment [160] = '/**'
  preproc_include [164] = '#include <stdio.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<stdio.h>'
  preproc_include [164] = '#include <stdlib.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<stdlib.h>'
  preproc_include [164] = '#include <string.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<string.h>'
  preproc_include [164] = '#include <stdint.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<stdint.h>'
  preproc_include [164] = '#include <stdarg.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<stdarg.h>'
  preproc_include [164] = '#include <signal.h>'
    #include [2] = '#include'
    path: system_lib_string [155] = '<signal.h>'
  comment [160] = '/**'
  preproc_def [165] = '#define MAX_SIZE 1024'
    #define [4] = '#define'
    name: identifier [1] = 'MAX_SIZE'
    value: preproc_arg [18] = '1024'
  comment [160] = '/**'
  preproc_function_def [166] = '#define SQUARE(x) ((x) * (x))'
    #define [4] = '#define'
    name: identifier [1] = 'SQUARE'
    parameters: preproc_params [167] = '(x)'
      ( [5] = '('
      identifier [1] = 'x'
      ) [8] = ')'
    value: preproc_arg [18] = '((x) * (x))'
  comment [160] = '/**'
  preproc_function_def [166]
    #define [4] = '#define'
    name: identifier [1] = 'DEBUG_PRINT'
    parameters: preproc_params [167] = '(fmt, ...)'
      ( [5] = '('
      identifier [1] = 'fmt'
      , [7] = ','
      ... [6] = '...'
      ) [8] = ')'
    value: preproc_arg [18] = 'printf("[DEBUG] " fmt "\n", ##__VA_ARGS__)'
  comment [160] = '// Forward declarations with documentation'
  struct_specifier [249] = 'struct Node'
    struct [96] = 'struct'
    name: type_identifier [362] = 'Node'
  ; [42] = ';'
  type_definition [199] = 'typedef struct Node Node;'
    typedef [44] = 'typedef'
    type: struct_specifier [249] = 'struct Node'
      struct [96] = 'struct'
      name: type_identifier [362] = 'Node'
    declarator: type_identifier [362] = 'Node'
    ; [42] = ';'
  comment [160] = '/**'
  type_definition [199]
    typedef [44] = 'typedef'
    type: primitive_type [93] = 'int'
    declarator: function_declarator [230]
      declarator: parenthesized_declarator [219] = '(*compare_fn)'
        ( [5] = '('
        pointer_declarator [226] = '*compare_fn'
          * [26] = '*'
          declarator: type_identifier [362] = 'compare_fn'
        ) [8] = ')'
      parameters: parameter_list [258] = '(const void *, const void *)'
        ( [5] = '('
        parameter_declaration [260] = 'const void *'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'void'
          declarator: abstract_pointer_declarator [229] = '*'
            * [26] = '*'
        , [7] = ','
        parameter_declaration [260] = 'const void *'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'void'
          declarator: abstract_pointer_declarator [229] = '*'
            * [26] = '*'
        ) [8] = ')'
    ; [42] = ';'
  comment [160] = '/**'
  type_definition [199] = 'typedef uint32_t user_id_t;'
    typedef [44] = 'typedef'
    type: primitive_type [93] = 'uint32_t'
    declarator: type_identifier [362] = 'user_id_t'
    ; [42] = ';'
  comment [160] = '/**'
  type_definition [199] = 'typedef enum {'
    typedef [44] = 'typedef'
    type: enum_specifier [247] = 'enum {'
      enum [94] = 'enum'
      body: enumerator_list [248] = '{'
        { [64] = '{'
        enumerator [256] = 'STATUS_OK = 0'
          name: identifier [1] = 'STATUS_OK'
          = [73] = '='
          value: number_literal [141] = '0'
        , [7] = ','
        comment [160] = '/**< Operation completed successfully */'
        enumerator [256] = 'STATUS_ERROR = -1'
          name: identifier [1] = 'STATUS_ERROR'
          = [73] = '='
          value: number_literal [141] = '-1'
        , [7] = ','
        comment [160] = '/**< General error occurred */'
        enumerator [256] = 'STATUS_INVALID = -2'
          name: identifier [1] = 'STATUS_INVALID'
          = [73] = '='
          value: number_literal [141] = '-2'
        comment [160] = '/**< Invalid parameters provided */'
        } [65] = '}'
    declarator: type_identifier [362] = 'status_t'
    ; [42] = ';'
  comment [160] = '/**'
  struct_specifier [249] = 'struct Point {'
    struct [96] = 'struct'
    name: type_identifier [362] = 'Point'
    body: field_declaration_list [251] = '{'
      { [64] = '{'
      field_declaration [253] = 'float x;'
        type: primitive_type [93] = 'float'
        declarator: field_identifier [360] = 'x'
        ; [42] = ';'
      comment [160] = '/**< X coordinate */'
      field_declaration [253] = 'float y;'
        type: primitive_type [93] = 'float'
        declarator: field_identifier [360] = 'y'
        ; [42] = ';'
      comment [160] = '/**< Y coordinate */'
      field_declaration [253] = 'const char *label;'
        type_qualifier [243] = 'const'
          const [82] = 'const'
        type: primitive_type [93] = 'char'
        declarator: pointer_declarator [226] = '*label'
          * [26] = '*'
          declarator: field_identifier [360] = 'label'
        ; [42] = ';'
      comment [160] = '/**< Optional descriptive label */'
      } [65] = '}'
  ; [42] = ';'
  comment [160] = '/**'
  type_definition [199] = 'typedef struct {'
    typedef [44] = 'typedef'
    type: struct_specifier [249] = 'struct {'
      struct [96] = 'struct'
      body: field_declaration_list [251] = '{'
        { [64] = '{'
        field_declaration [253] = 'int width;'
          type: primitive_type [93] = 'int'
          declarator: field_identifier [360] = 'width'
          ; [42] = ';'
        comment [160] = '/**< Rectangle width in units */'
        field_declaration [253] = 'int height;'
          type: primitive_type [93] = 'int'
          declarator: field_identifier [360] = 'height'
          ; [42] = ';'
        comment [160] = '/**< Rectangle height in units */'
        field_declaration [253] = 'struct Point origin;'
          type: struct_specifier [249] = 'struct Point'
            struct [96] = 'struct'
            name: type_identifier [362] = 'Point'
          declarator: field_identifier [360] = 'origin'
          ; [42] = ';'
        comment [160] = '/**< Origin point of the rectangle */'
        } [65] = '}'
    declarator: type_identifier [362] = 'Rectangle'
    ; [42] = ';'
  comment [160] = '/**'
  struct_specifier [249] = 'struct Node {'
    struct [96] = 'struct'
    name: type_identifier [362] = 'Node'
    body: field_declaration_list [251] = '{'
      { [64] = '{'
      field_declaration [253] = 'int data;'
        type: primitive_type [93] = 'int'
        declarator: field_identifier [360] = 'data'
        ; [42] = ';'
      comment [160] = '/**< Integer data payload */'
      field_declaration [253] = 'struct Node *next;'
        type: struct_specifier [249] = 'struct Node'
          struct [96] = 'struct'
          name: type_identifier [362] = 'Node'
        declarator: pointer_declarator [226] = '*next'
          * [26] = '*'
          declarator: field_identifier [360] = 'next'
        ; [42] = ';'
      comment [160] = '/**< Pointer to next node */'
      field_declaration [253] = 'struct Node *prev;'
        type: struct_specifier [249] = 'struct Node'
          struct [96] = 'struct'
          name: type_identifier [362] = 'Node'
        declarator: pointer_declarator [226] = '*prev'
          * [26] = '*'
          declarator: field_identifier [360] = 'prev'
        ; [42] = ';'
      comment [160] = '/**< Pointer to previous node */'
      } [65] = '}'
  ; [42] = ';'
  comment [160] = '/**'
  union_specifier [250] = 'union Value {'
    union [97] = 'union'
    name: type_identifier [362] = 'Value'
    body: field_declaration_list [251] = '{'
      { [64] = '{'
      field_declaration [253] = 'int i;'
        type: primitive_type [93] = 'int'
        declarator: field_identifier [360] = 'i'
        ; [42] = ';'
      comment [160] = '/**< Integer value */'
      field_declaration [253] = 'float f;'
        type: primitive_type [93] = 'float'
        declarator: field_identifier [360] = 'f'
        ; [42] = ';'
      comment [160] = '/**< Floating-point value */'
      field_declaration [253] = 'char str[32];'
        type: primitive_type [93] = 'char'
        declarator: array_declarator [236] = 'str[32]'
          declarator: field_identifier [360] = 'str'
          [ [70] = '['
          size: number_literal [141] = '32'
          ] [72] = ']'
        ; [42] = ';'
      comment [160] = '/**< String value with fixed size */'
      field_declaration [253] = 'void *ptr;'
        type: primitive_type [93] = 'void'
        declarator: pointer_declarator [226] = '*ptr'
          * [26] = '*'
          declarator: field_identifier [360] = 'ptr'
        ; [42] = ';'
      comment [160] = '/**< Generic pointer value */'
      } [65] = '}'
  ; [42] = ';'
  comment [160] = '// Function prototypes with documentation'
  comment [160] = '/**'
  declaration [198] = 'int add(int a, int b);'
    type: primitive_type [93] = 'int'
    declarator: function_declarator [230] = 'add(int a, int b)'
      declarator: identifier [1] = 'add'
      parameters: parameter_list [258] = '(int a, int b)'
        ( [5] = '('
        parameter_declaration [260] = 'int a'
          type: primitive_type [93] = 'int'
          declarator: identifier [1] = 'a'
        , [7] = ','
        parameter_declaration [260] = 'int b'
          type: primitive_type [93] = 'int'
          declarator: identifier [1] = 'b'
        ) [8] = ')'
    ; [42] = ';'
  comment [160] = '/**'
  declaration [198] = 'void print_point(const struct Point *p);'
    type: primitive_type [93] = 'void'
    declarator: function_declarator [230] = 'print_point(const struct Point *p)'
      declarator: identifier [1] = 'print_point'
      parameters: parameter_list [258] = '(const struct Point *p)'
        ( [5] = '('
        parameter_declaration [260] = 'const struct Point *p'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: struct_specifier [249] = 'struct Point'
            struct [96] = 'struct'
            name: type_identifier [362] = 'Point'
          declarator: pointer_declarator [226] = '*p'
            * [26] = '*'
            declarator: identifier [1] = 'p'
        ) [8] = ')'
    ; [42] = ';'
  comment [160] = '/**'
  declaration [198]
    type: type_identifier [362] = 'Rectangle'
    declarator: pointer_declarator [226]
      * [26] = '*'
      declarator: function_declarator [230]
        declarator: identifier [1] = 'create_rectangle'
        parameters: parameter_list [258] = '(int w, int h, struct Point origin)'
          ( [5] = '('
          parameter_declaration [260] = 'int w'
            type: primitive_type [93] = 'int'
            declarator: identifier [1] = 'w'
          , [7] = ','
          parameter_declaration [260] = 'int h'
            type: primitive_type [93] = 'int'
            declarator: identifier [1] = 'h'
          , [7] = ','
          parameter_declaration [260] = 'struct Point origin'
            type: struct_specifier [249] = 'struct Point'
              struct [96] = 'struct'
              name: type_identifier [362] = 'Point'
            declarator: identifier [1] = 'origin'
          ) [8] = ')'
    ; [42] = ';'
  comment [160] = '/**'
  declaration [198]
    type: primitive_type [93] = 'int'
    declarator: function_declarator [230]
      declarator: identifier [1] = 'compare_ints'
      parameters: parameter_list [258] = '(const void *a, const void *b)'
        ( [5] = '('
        parameter_declaration [260] = 'const void *a'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'void'
          declarator: pointer_declarator [226] = '*a'
            * [26] = '*'
            declarator: identifier [1] = 'a'
        , [7] = ','
        parameter_declaration [260] = 'const void *b'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'void'
          declarator: pointer_declarator [226] = '*b'
            * [26] = '*'
            declarator: identifier [1] = 'b'
        ) [8] = ')'
    ; [42] = ';'
  comment [160] = '/**'
  declaration [198] = 'static inline int is_valid(int value);'
    storage_class_specifier [242] = 'static'
      static [71] = 'static'
    storage_class_specifier [242] = 'inline'
      inline [76] = 'inline'
    type: primitive_type [93] = 'int'
    declarator: function_declarator [230] = 'is_valid(int value)'
      declarator: identifier [1] = 'is_valid'
      parameters: parameter_list [258] = '(int value)'
        ( [5] = '('
        parameter_declaration [260] = 'int value'
          type: primitive_type [93] = 'int'
          declarator: identifier [1] = 'value'
        ) [8] = ')'
    ; [42] = ';'
  comment [160] = '// Global variables with documentation'
  comment [160] = '/**'
  declaration [198] = 'static int global_counter = 0;'
    storage_class_specifier [242] = 'static'
      static [71] = 'static'
    type: primitive_type [93] = 'int'
    declarator: init_declarator [240] = 'global_counter = 0'
      declarator: identifier [1] = 'global_counter'
      = [73] = '='
      value: number_literal [141] = '0'
    ; [42] = ';'
  comment [160] = '/**'
  declaration [198] = 'extern const char *program_name;'
    storage_class_specifier [242] = 'extern'
      extern [45] = 'extern'
    type_qualifier [243] = 'const'
      const [82] = 'const'
    type: primitive_type [93] = 'char'
    declarator: pointer_declarator [226] = '*program_name'
      * [26] = '*'
      declarator: identifier [1] = 'program_name'
    ; [42] = ';'
  comment [160] = '/**'
  declaration [198] = 'volatile sig_atomic_t signal_flag = 0;'
    type_qualifier [243] = 'volatile'
      volatile [84] = 'volatile'
    type: type_identifier [362] = 'sig_atomic_t'
    declarator: init_declarator [240] = 'signal_flag = 0'
      declarator: identifier [1] = 'signal_flag'
      = [73] = '='
      value: number_literal [141] = '0'
    ; [42] = ';'
  comment [160] = '// Function definitions with comprehensive documentation'
  comment [160] = '/**'
  function_definition [196] = 'int add(int a, int b) {'
    type: primitive_type [93] = 'int'
    declarator: function_declarator [230] = 'add(int a, int b)'
      declarator: identifier [1] = 'add'
      parameters: parameter_list [258] = '(int a, int b)'
        ( [5] = '('
        parameter_declaration [260] = 'int a'
          type: primitive_type [93] = 'int'
          declarator: identifier [1] = 'a'
        , [7] = ','
        parameter_declaration [260] = 'int b'
          type: primitive_type [93] = 'int'
          declarator: identifier [1] = 'b'
        ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      return_statement [275] = 'return a + b;'
        return [106] = 'return'
        binary_expression [290] = 'a + b'
          left: identifier [1] = 'a'
          operator: + [25] = '+'
          right: identifier [1] = 'b'
        ; [42] = ';'
      } [65] = '}'
  comment [160] = '/**'
  function_definition [196]
    type: primitive_type [93] = 'void'
    declarator: function_declarator [230] = 'print_point(const struct Point *p)'
      declarator: identifier [1] = 'print_point'
      parameters: parameter_list [258] = '(const struct Point *p)'
        ( [5] = '('
        parameter_declaration [260] = 'const struct Point *p'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: struct_specifier [249] = 'struct Point'
            struct [96] = 'struct'
            name: type_identifier [362] = 'Point'
          declarator: pointer_declarator [226] = '*p'
            * [26] = '*'
            declarator: identifier [1] = 'p'
        ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      if_statement [267] = 'if (p == NULL) {'
        if [98] = 'if'
        condition: parenthesized_expression [312] = '(p == NULL)'
          ( [5] = '('
          binary_expression [290] = 'p == NULL'
            left: identifier [1] = 'p'
            operator: == [34] = '=='
            right: null [321] = 'NULL'
              NULL [158] = 'NULL'
          ) [8] = ')'
        consequence: compound_statement [241] = '{'
          { [64] = '{'
          expression_statement [266] = 'printf("Point is NULL\n");'
            call_expression [299] = 'printf("Point is NULL\n")'
              function: identifier [1] = 'printf'
              arguments: argument_list [309] = '("Point is NULL\n")'
                ( [5] = '('
                string_literal [320] = '"Point is NULL\n"'
                  " [152] = '"'
                  string_content [153] = 'Point is NULL'
                  escape_sequence [154] = '\n'
                  " [152] = '"'
                ) [8] = ')'
            ; [42] = ';'
          return_statement [275] = 'return;'
            return [106] = 'return'
            ; [42] = ';'
          } [65] = '}'
      expression_statement [266]
        call_expression [299]
          function: identifier [1] = 'printf'
          arguments: argument_list [309]
            ( [5] = '('
            string_literal [320] = '"Point: (%.2f, %.2f) - %s\n"'
              " [152] = '"'
              string_content [153] = 'Point: (%.2f, %.2f) - %s'
              escape_sequence [154] = '\n'
              " [152] = '"'
            , [7] = ','
            field_expression [310] = 'p->x'
              argument: identifier [1] = 'p'
              operator: -> [140] = '->'
              field: field_identifier [360] = 'x'
            , [7] = ','
            field_expression [310] = 'p->y'
              argument: identifier [1] = 'p'
              operator: -> [140] = '->'
              field: field_identifier [360] = 'y'
            , [7] = ','
            conditional_expression [286] = 'p->label ? p->label : "unnamed"'
              condition: field_expression [310] = 'p->label'
                argument: identifier [1] = 'p'
                operator: -> [140] = '->'
                field: field_identifier [360] = 'label'
              ? [114] = '?'
              consequence: field_expression [310] = 'p->label'
                argument: identifier [1] = 'p'
                operator: -> [140] = '->'
                field: field_identifier [360] = 'label'
              : [95] = ':'
              alternative: string_literal [320] = '"unnamed"'
                " [152] = '"'
                string_content [153] = 'unnamed'
                " [152] = '"'
            ) [8] = ')'
        ; [42] = ';'
      } [65] = '}'
  comment [160] = '/**'
  function_definition [196]
    type: type_identifier [362] = 'Rectangle'
    declarator: pointer_declarator [226]
      * [26] = '*'
      declarator: function_declarator [230]
        declarator: identifier [1] = 'create_rectangle'
        parameters: parameter_list [258] = '(int w, int h, struct Point origin)'
          ( [5] = '('
          parameter_declaration [260] = 'int w'
            type: primitive_type [93] = 'int'
            declarator: identifier [1] = 'w'
          , [7] = ','
          parameter_declaration [260] = 'int h'
            type: primitive_type [93] = 'int'
            declarator: identifier [1] = 'h'
          , [7] = ','
          parameter_declaration [260] = 'struct Point origin'
            type: struct_specifier [249] = 'struct Point'
              struct [96] = 'struct'
              name: type_identifier [362] = 'Point'
            declarator: identifier [1] = 'origin'
          ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      declaration [198]
        type: type_identifier [362] = 'Rectangle'
        declarator: init_declarator [240] = '*rect = malloc(sizeof(Rectangle))'
          declarator: pointer_declarator [226] = '*rect'
            * [26] = '*'
            declarator: identifier [1] = 'rect'
          = [73] = '='
          value: call_expression [299] = 'malloc(sizeof(Rectangle))'
            function: identifier [1] = 'malloc'
            arguments: argument_list [309] = '(sizeof(Rectangle))'
              ( [5] = '('
              sizeof_expression [294] = 'sizeof(Rectangle)'
                sizeof [127] = 'sizeof'
                value: parenthesized_expression [312] = '(Rectangle)'
                  ( [5] = '('
                  identifier [1] = 'Rectangle'
                  ) [8] = ')'
              ) [8] = ')'
        ; [42] = ';'
      if_statement [267] = 'if (!rect) {'
        if [98] = 'if'
        condition: parenthesized_expression [312] = '(!rect)'
          ( [5] = '('
          unary_expression [289] = '!rect'
            operator: ! [22] = '!'
            argument: identifier [1] = 'rect'
          ) [8] = ')'
        consequence: compound_statement [241] = '{'
          { [64] = '{'
          return_statement [275] = 'return NULL;'
            return [106] = 'return'
            null [321] = 'NULL'
              NULL [158] = 'NULL'
            ; [42] = ';'
          } [65] = '}'
      expression_statement [266] = 'rect->width = w;'
        assignment_expression [287] = 'rect->width = w'
          left: field_expression [310] = 'rect->width'
            argument: identifier [1] = 'rect'
            operator: -> [140] = '->'
            field: field_identifier [360] = 'width'
          operator: = [73] = '='
          right: identifier [1] = 'w'
        ; [42] = ';'
      expression_statement [266] = 'rect->height = h;'
        assignment_expression [287] = 'rect->height = h'
          left: field_expression [310] = 'rect->height'
            argument: identifier [1] = 'rect'
            operator: -> [140] = '->'
            field: field_identifier [360] = 'height'
          operator: = [73] = '='
          right: identifier [1] = 'h'
        ; [42] = ';'
      expression_statement [266] = 'rect->origin = origin;'
        assignment_expression [287] = 'rect->origin = origin'
          left: field_expression [310] = 'rect->origin'
            argument: identifier [1] = 'rect'
            operator: -> [140] = '->'
            field: field_identifier [360] = 'origin'
          operator: = [73] = '='
          right: identifier [1] = 'origin'
        ; [42] = ';'
      return_statement [275] = 'return rect;'
        return [106] = 'return'
        identifier [1] = 'rect'
        ; [42] = ';'
      } [65] = '}'
  comment [160] = '/**'
  function_definition [196]
    type: primitive_type [93] = 'int'
    declarator: function_declarator [230]
      declarator: identifier [1] = 'compare_ints'
      parameters: parameter_list [258] = '(const void *a, const void *b)'
        ( [5] = '('
        parameter_declaration [260] = 'const void *a'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'void'
          declarator: pointer_declarator [226] = '*a'
            * [26] = '*'
            declarator: identifier [1] = 'a'
        , [7] = ','
        parameter_declaration [260] = 'const void *b'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'void'
          declarator: pointer_declarator [226] = '*b'
            * [26] = '*'
            declarator: identifier [1] = 'b'
        ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      declaration [198] = 'int ia = *(const int*)a;'
        type: primitive_type [93] = 'int'
        declarator: init_declarator [240] = 'ia = *(const int*)a'
          declarator: identifier [1] = 'ia'
          = [73] = '='
          value: pointer_expression [288] = '*(const int*)a'
            operator: * [26] = '*'
            argument: cast_expression [292] = '(const int*)a'
              ( [5] = '('
              type: type_descriptor [293] = 'const int*'
                type_qualifier [243] = 'const'
                  const [82] = 'const'
                type: primitive_type [93] = 'int'
                declarator: abstract_pointer_declarator [229] = '*'
                  * [26] = '*'
              ) [8] = ')'
              value: identifier [1] = 'a'
        ; [42] = ';'
      declaration [198] = 'int ib = *(const int*)b;'
        type: primitive_type [93] = 'int'
        declarator: init_declarator [240] = 'ib = *(const int*)b'
          declarator: identifier [1] = 'ib'
          = [73] = '='
          value: pointer_expression [288] = '*(const int*)b'
            operator: * [26] = '*'
            argument: cast_expression [292] = '(const int*)b'
              ( [5] = '('
              type: type_descriptor [293] = 'const int*'
                type_qualifier [243] = 'const'
                  const [82] = 'const'
                type: primitive_type [93] = 'int'
                declarator: abstract_pointer_declarator [229] = '*'
                  * [26] = '*'
              ) [8] = ')'
              value: identifier [1] = 'b'
        ; [42] = ';'
      return_statement [275] = 'return (ia > ib) - (ia < ib);'
        return [106] = 'return'
        binary_expression [290] = '(ia > ib) - (ia < ib)'
          left: parenthesized_expression [312] = '(ia > ib)'
            ( [5] = '('
            binary_expression [290] = 'ia > ib'
              left: identifier [1] = 'ia'
              operator: > [36] = '>'
              right: identifier [1] = 'ib'
            ) [8] = ')'
          operator: - [24] = '-'
          right: parenthesized_expression [312] = '(ia < ib)'
            ( [5] = '('
            binary_expression [290] = 'ia < ib'
              left: identifier [1] = 'ia'
              operator: < [39] = '<'
              right: identifier [1] = 'ib'
            ) [8] = ')'
        ; [42] = ';'
      } [65] = '}'
  comment [160] = '/**'
  function_definition [196] = 'static inline int is_valid(int value) {'
    storage_class_specifier [242] = 'static'
      static [71] = 'static'
    storage_class_specifier [242] = 'inline'
      inline [76] = 'inline'
    type: primitive_type [93] = 'int'
    declarator: function_declarator [230] = 'is_valid(int value)'
      declarator: identifier [1] = 'is_valid'
      parameters: parameter_list [258] = '(int value)'
        ( [5] = '('
        parameter_declaration [260] = 'int value'
          type: primitive_type [93] = 'int'
          declarator: identifier [1] = 'value'
        ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      return_statement [275] = 'return value >= 0 && value < MAX_SIZE;'
        return [106] = 'return'
        binary_expression [290] = 'value >= 0 && value < MAX_SIZE'
          left: binary_expression [290] = 'value >= 0'
            left: identifier [1] = 'value'
            operator: >= [37] = '>='
            right: number_literal [141] = '0'
          operator: && [30] = '&&'
          right: binary_expression [290] = 'value < MAX_SIZE'
            left: identifier [1] = 'value'
            operator: < [39] = '<'
            right: identifier [1] = 'MAX_SIZE'
        ; [42] = ';'
      } [65] = '}'
  comment [160] = '/**'
  function_definition [196] = 'void complex_function(void) {'
    type: primitive_type [93] = 'void'
    declarator: function_declarator [230] = 'complex_function(void)'
      declarator: identifier [1] = 'complex_function'
      parameters: parameter_list [258] = '(void)'
        ( [5] = '('
        parameter_declaration [260] = 'void'
          type: primitive_type [93] = 'void'
        ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      comment [160] = '// Local variable initialization with documentation'
      declaration [198]
        type: primitive_type [93] = 'int'
        declarator: init_declarator [240]
          declarator: array_declarator [236] = 'numbers[10]'
            declarator: identifier [1] = 'numbers'
            [ [70] = '['
            size: number_literal [141] = '10'
            ] [72] = ']'
          = [73] = '='
          value: initializer_list [313] = '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}'
            { [64] = '{'
            number_literal [141] = '1'
            , [7] = ','
            number_literal [141] = '2'
            , [7] = ','
            number_literal [141] = '3'
            , [7] = ','
            number_literal [141] = '4'
            , [7] = ','
            number_literal [141] = '5'
            , [7] = ','
            number_literal [141] = '6'
            , [7] = ','
            number_literal [141] = '7'
            , [7] = ','
            number_literal [141] = '8'
            , [7] = ','
            number_literal [141] = '9'
            , [7] = ','
            number_literal [141] = '10'
            } [65] = '}'
        ; [42] = ';'
      comment [160] = '/**< Test array for sorting */'
      comment [160] = '/**'
      declaration [198] = 'struct Point points[] = {'
        type: struct_specifier [249] = 'struct Point'
          struct [96] = 'struct'
          name: type_identifier [362] = 'Point'
        declarator: init_declarator [240] = 'points[] = {'
          declarator: array_declarator [236] = 'points[]'
            declarator: identifier [1] = 'points'
            [ [70] = '['
            ] [72] = ']'
          = [73] = '='
          value: initializer_list [313] = '{'
            { [64] = '{'
            initializer_list [313] = '{0.0f, 0.0f, "origin"}'
              { [64] = '{'
              number_literal [141] = '0.0f'
              , [7] = ','
              number_literal [141] = '0.0f'
              , [7] = ','
              string_literal [320] = '"origin"'
                " [152] = '"'
                string_content [153] = 'origin'
                " [152] = '"'
              } [65] = '}'
            , [7] = ','
            initializer_list [313] = '{1.0f, 1.0f, "unit"}'
              { [64] = '{'
              number_literal [141] = '1.0f'
              , [7] = ','
              number_literal [141] = '1.0f'
              , [7] = ','
              string_literal [320] = '"unit"'
                " [152] = '"'
                string_content [153] = 'unit'
                " [152] = '"'
              } [65] = '}'
            , [7] = ','
            initializer_list [313] = '{-1.0f, -1.0f, "negative"}'
              { [64] = '{'
              number_literal [141] = '-1.0f'
              , [7] = ','
              number_literal [141] = '-1.0f'
              , [7] = ','
              string_literal [320] = '"negative"'
                " [152] = '"'
                string_content [153] = 'negative'
                " [152] = '"'
              } [65] = '}'
            } [65] = '}'
        ; [42] = ';'
      comment [160] = '// Control structure demonstrations'
      for_statement [273] = 'for (int i = 0; i < 10; i++) {'
        for [105] = 'for'
        ( [5] = '('
        initializer: declaration [198] = 'int i = 0;'
          type: primitive_type [93] = 'int'
          declarator: init_declarator [240] = 'i = 0'
            declarator: identifier [1] = 'i'
            = [73] = '='
            value: number_literal [141] = '0'
          ; [42] = ';'
        condition: binary_expression [290] = 'i < 10'
          left: identifier [1] = 'i'
          operator: < [39] = '<'
          right: number_literal [141] = '10'
        ; [42] = ';'
        update: update_expression [291] = 'i++'
          argument: identifier [1] = 'i'
          operator: ++ [126] = '++'
        ) [8] = ')'
        body: compound_statement [241] = '{'
          { [64] = '{'
          if_statement [267] = 'if (numbers[i] % 2 == 0) {'
            if [98] = 'if'
            condition: parenthesized_expression [312] = '(numbers[i] % 2 == 0)'
              ( [5] = '('
              binary_expression [290] = 'numbers[i] % 2 == 0'
                left: binary_expression [290] = 'numbers[i] % 2'
                  left: subscript_expression [298] = 'numbers[i]'
                    argument: identifier [1] = 'numbers'
                    [ [70] = '['
                    index: identifier [1] = 'i'
                    ] [72] = ']'
                  operator: % [28] = '%'
                  right: number_literal [141] = '2'
                operator: == [34] = '=='
                right: number_literal [141] = '0'
              ) [8] = ')'
            consequence: compound_statement [241] = '{'
              { [64] = '{'
              expression_statement [266]
                call_expression [299]
                  function: identifier [1] = 'DEBUG_PRINT'
                  arguments: argument_list [309] = '("Even number: %d", numbers[i])'
                    ( [5] = '('
                    string_literal [320] = '"Even number: %d"'
                      " [152] = '"'
                      string_content [153] = 'Even number: %d'
                      " [152] = '"'
                    , [7] = ','
                    subscript_expression [298] = 'numbers[i]'
                      argument: identifier [1] = 'numbers'
                      [ [70] = '['
                      index: identifier [1] = 'i'
                      ] [72] = ']'
                    ) [8] = ')'
                ; [42] = ';'
              } [65] = '}'
            alternative: else_clause [268] = 'else {'
              else [99] = 'else'
              compound_statement [241] = '{'
                { [64] = '{'
                expression_statement [266]
                  call_expression [299]
                    function: identifier [1] = 'DEBUG_PRINT'
                    arguments: argument_list [309] = '("Odd number: %d", numbers[i])'
                      ( [5] = '('
                      string_literal [320] = '"Odd number: %d"'
                        " [152] = '"'
                        string_content [153] = 'Odd number: %d'
                        " [152] = '"'
                      , [7] = ','
                      subscript_expression [298] = 'numbers[i]'
                        argument: identifier [1] = 'numbers'
                        [ [70] = '['
                        index: identifier [1] = 'i'
                        ] [72] = ']'
                      ) [8] = ')'
                  ; [42] = ';'
                } [65] = '}'
          } [65] = '}'
      comment [160] = '// Switch statement with comprehensive cases'
      declaration [198] = 'status_t status = STATUS_OK;'
        type: type_identifier [362] = 'status_t'
        declarator: init_declarator [240] = 'status = STATUS_OK'
          declarator: identifier [1] = 'status'
          = [73] = '='
          value: identifier [1] = 'STATUS_OK'
        ; [42] = ';'
      switch_statement [269] = 'switch (status) {'
        switch [100] = 'switch'
        condition: parenthesized_expression [312] = '(status)'
          ( [5] = '('
          identifier [1] = 'status'
          ) [8] = ')'
        body: compound_statement [241] = '{'
          { [64] = '{'
          case_statement [270] = 'case STATUS_OK:'
            case [101] = 'case'
            value: identifier [1] = 'STATUS_OK'
            : [95] = ':'
            expression_statement [266] = 'printf("Operation successful\n");'
              call_expression [299] = 'printf("Operation successful\n")'
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("Operation successful\n")'
                  ( [5] = '('
                  string_literal [320] = '"Operation successful\n"'
                    " [152] = '"'
                    string_content [153] = 'Operation successful'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  ) [8] = ')'
              ; [42] = ';'
            break_statement [276] = 'break;'
              break [107] = 'break'
              ; [42] = ';'
          case_statement [270] = 'case STATUS_ERROR:'
            case [101] = 'case'
            value: identifier [1] = 'STATUS_ERROR'
            : [95] = ':'
            expression_statement [266] = 'printf("Error occurred\n");'
              call_expression [299] = 'printf("Error occurred\n")'
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("Error occurred\n")'
                  ( [5] = '('
                  string_literal [320] = '"Error occurred\n"'
                    " [152] = '"'
                    string_content [153] = 'Error occurred'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  ) [8] = ')'
              ; [42] = ';'
            break_statement [276] = 'break;'
              break [107] = 'break'
              ; [42] = ';'
          case_statement [270] = 'default:'
            default [102] = 'default'
            : [95] = ':'
            expression_statement [266] = 'printf("Unknown status\n");'
              call_expression [299] = 'printf("Unknown status\n")'
                function: identifier [1] = 'printf'
                arguments: argument_list [309] = '("Unknown status\n")'
                  ( [5] = '('
                  string_literal [320] = '"Unknown status\n"'
                    " [152] = '"'
                    string_content [153] = 'Unknown status'
                    escape_sequence [154] = '\n'
                    " [152] = '"'
                  ) [8] = ')'
              ; [42] = ';'
            break_statement [276] = 'break;'
              break [107] = 'break'
              ; [42] = ';'
          } [65] = '}'
      comment [160] = '// While loop demonstration'
      declaration [198] = 'int count = 0;'
        type: primitive_type [93] = 'int'
        declarator: init_declarator [240] = 'count = 0'
          declarator: identifier [1] = 'count'
          = [73] = '='
          value: number_literal [141] = '0'
        ; [42] = ';'
      while_statement [271] = 'while (count < 3) {'
        while [103] = 'while'
        condition: parenthesized_expression [312] = '(count < 3)'
          ( [5] = '('
          binary_expression [290] = 'count < 3'
            left: identifier [1] = 'count'
            operator: < [39] = '<'
            right: number_literal [141] = '3'
          ) [8] = ')'
        body: compound_statement [241] = '{'
          { [64] = '{'
          expression_statement [266] = 'print_point(&points[count]);'
            call_expression [299] = 'print_point(&points[count])'
              function: identifier [1] = 'print_point'
              arguments: argument_list [309] = '(&points[count])'
                ( [5] = '('
                pointer_expression [288] = '&points[count]'
                  operator: & [33] = '&'
                  argument: subscript_expression [298] = 'points[count]'
                    argument: identifier [1] = 'points'
                    [ [70] = '['
                    index: identifier [1] = 'count'
                    ] [72] = ']'
                ) [8] = ')'
            ; [42] = ';'
          expression_statement [266] = 'count++;'
            update_expression [291] = 'count++'
              argument: identifier [1] = 'count'
              operator: ++ [126] = '++'
            ; [42] = ';'
          } [65] = '}'
      comment [160] = '// Do-while loop for guaranteed execution'
      declaration [198] = 'int j = 0;'
        type: primitive_type [93] = 'int'
        declarator: init_declarator [240] = 'j = 0'
          declarator: identifier [1] = 'j'
          = [73] = '='
          value: number_literal [141] = '0'
        ; [42] = ';'
      do_statement [272] = 'do {'
        do [104] = 'do'
        body: compound_statement [241] = '{'
          { [64] = '{'
          expression_statement [266] = 'printf("Value: %d\n", SQUARE(j));'
            call_expression [299] = 'printf("Value: %d\n", SQUARE(j))'
              function: identifier [1] = 'printf'
              arguments: argument_list [309] = '("Value: %d\n", SQUARE(j))'
                ( [5] = '('
                string_literal [320] = '"Value: %d\n"'
                  " [152] = '"'
                  string_content [153] = 'Value: %d'
                  escape_sequence [154] = '\n'
                  " [152] = '"'
                , [7] = ','
                call_expression [299] = 'SQUARE(j)'
                  function: identifier [1] = 'SQUARE'
                  arguments: argument_list [309] = '(j)'
                    ( [5] = '('
                    identifier [1] = 'j'
                    ) [8] = ')'
                ) [8] = ')'
            ; [42] = ';'
          expression_statement [266] = 'j++;'
            update_expression [291] = 'j++'
              argument: identifier [1] = 'j'
              operator: ++ [126] = '++'
            ; [42] = ';'
          } [65] = '}'
        while [103] = 'while'
        condition: parenthesized_expression [312] = '(j < 3)'
          ( [5] = '('
          binary_expression [290] = 'j < 3'
            left: identifier [1] = 'j'
            operator: < [39] = '<'
            right: number_literal [141] = '3'
          ) [8] = ')'
        ; [42] = ';'
      comment [160] = '// Goto statement for cleanup patterns'
      if_statement [267] = 'if (global_counter > 100) {'
        if [98] = 'if'
        condition: parenthesized_expression [312] = '(global_counter > 100)'
          ( [5] = '('
          binary_expression [290] = 'global_counter > 100'
            left: identifier [1] = 'global_counter'
            operator: > [36] = '>'
            right: number_literal [141] = '100'
          ) [8] = ')'
        consequence: compound_statement [241] = '{'
          { [64] = '{'
          goto_statement [278] = 'goto cleanup;'
            goto [109] = 'goto'
            label: statement_identifier [361] = 'cleanup'
            ; [42] = ';'
          } [65] = '}'
      comment [160] = '// Function pointer demonstration'
      declaration [198] = 'compare_fn cmp = compare_ints;'
        type: type_identifier [362] = 'compare_fn'
        declarator: init_declarator [240] = 'cmp = compare_ints'
          declarator: identifier [1] = 'cmp'
          = [73] = '='
          value: identifier [1] = 'compare_ints'
        ; [42] = ';'
      expression_statement [266] = 'qsort(numbers, 10, sizeof(int), cmp);'
        call_expression [299] = 'qsort(numbers, 10, sizeof(int), cmp)'
          function: identifier [1] = 'qsort'
          arguments: argument_list [309] = '(numbers, 10, sizeof(int), cmp)'
            ( [5] = '('
            identifier [1] = 'numbers'
            , [7] = ','
            number_literal [141] = '10'
            , [7] = ','
            sizeof_expression [294] = 'sizeof(int)'
              sizeof [127] = 'sizeof'
              ( [5] = '('
              type: type_descriptor [293] = 'int'
                type: primitive_type [93] = 'int'
              ) [8] = ')'
            , [7] = ','
            identifier [1] = 'cmp'
            ) [8] = ')'
        ; [42] = ';'
      comment [160] = '// Union usage demonstration'
      declaration [198] = 'union Value val;'
        type: union_specifier [250] = 'union Value'
          union [97] = 'union'
          name: type_identifier [362] = 'Value'
        declarator: identifier [1] = 'val'
        ; [42] = ';'
      expression_statement [266] = 'val.i = 42;'
        assignment_expression [287] = 'val.i = 42'
          left: field_expression [310] = 'val.i'
            argument: identifier [1] = 'val'
            operator: . [139] = '.'
            field: field_identifier [360] = 'i'
          operator: = [73] = '='
          right: number_literal [141] = '42'
        ; [42] = ';'
      expression_statement [266] = 'printf("Integer value: %d\n", val.i);'
        call_expression [299] = 'printf("Integer value: %d\n", val.i)'
          function: identifier [1] = 'printf'
          arguments: argument_list [309] = '("Integer value: %d\n", val.i)'
            ( [5] = '('
            string_literal [320] = '"Integer value: %d\n"'
              " [152] = '"'
              string_content [153] = 'Integer value: %d'
              escape_sequence [154] = '\n'
              " [152] = '"'
            , [7] = ','
            field_expression [310] = 'val.i'
              argument: identifier [1] = 'val'
              operator: . [139] = '.'
              field: field_identifier [360] = 'i'
            ) [8] = ')'
        ; [42] = ';'
      expression_statement [266] = 'val.f = 3.14f;'
        assignment_expression [287] = 'val.f = 3.14f'
          left: field_expression [310] = 'val.f'
            argument: identifier [1] = 'val'
            operator: . [139] = '.'
            field: field_identifier [360] = 'f'
          operator: = [73] = '='
          right: number_literal [141] = '3.14f'
        ; [42] = ';'
      expression_statement [266] = 'printf("Float value: %.2f\n", val.f);'
        call_expression [299] = 'printf("Float value: %.2f\n", val.f)'
          function: identifier [1] = 'printf'
          arguments: argument_list [309] = '("Float value: %.2f\n", val.f)'
            ( [5] = '('
            string_literal [320] = '"Float value: %.2f\n"'
              " [152] = '"'
              string_content [153] = 'Float value: %.2f'
              escape_sequence [154] = '\n'
              " [152] = '"'
            , [7] = ','
            field_expression [310] = 'val.f'
              argument: identifier [1] = 'val'
              operator: . [139] = '.'
              field: field_identifier [360] = 'f'
            ) [8] = ')'
        ; [42] = ';'
      labeled_statement [264] = 'cleanup:'
        label: statement_identifier [361] = 'cleanup'
        : [95] = ':'
        expression_statement [266] = 'printf("Cleanup completed\n");'
          call_expression [299] = 'printf("Cleanup completed\n")'
            function: identifier [1] = 'printf'
            arguments: argument_list [309] = '("Cleanup completed\n")'
              ( [5] = '('
              string_literal [320] = '"Cleanup completed\n"'
                " [152] = '"'
                string_content [153] = 'Cleanup completed'
                escape_sequence [154] = '\n'
                " [152] = '"'
              ) [8] = ')'
          ; [42] = ';'
      } [65] = '}'
  comment [160] = '/**'
  function_definition [196]
    type: primitive_type [93] = 'void'
    declarator: function_declarator [230] = 'debug_log(const char *format, ...)'
      declarator: identifier [1] = 'debug_log'
      parameters: parameter_list [258] = '(const char *format, ...)'
        ( [5] = '('
        parameter_declaration [260] = 'const char *format'
          type_qualifier [243] = 'const'
            const [82] = 'const'
          type: primitive_type [93] = 'char'
          declarator: pointer_declarator [226] = '*format'
            * [26] = '*'
            declarator: identifier [1] = 'format'
        , [7] = ','
        variadic_parameter [257] = '...'
          ... [6] = '...'
        ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      declaration [198] = 'va_list args;'
        type: type_identifier [362] = 'va_list'
        declarator: identifier [1] = 'args'
        ; [42] = ';'
      expression_statement [266] = 'va_start(args, format);'
        call_expression [299] = 'va_start(args, format)'
          function: identifier [1] = 'va_start'
          arguments: argument_list [309] = '(args, format)'
            ( [5] = '('
            identifier [1] = 'args'
            , [7] = ','
            identifier [1] = 'format'
            ) [8] = ')'
        ; [42] = ';'
      expression_statement [266] = 'vprintf(format, args);'
        call_expression [299] = 'vprintf(format, args)'
          function: identifier [1] = 'vprintf'
          arguments: argument_list [309] = '(format, args)'
            ( [5] = '('
            identifier [1] = 'format'
            , [7] = ','
            identifier [1] = 'args'
            ) [8] = ')'
        ; [42] = ';'
      expression_statement [266] = 'va_end(args);'
        call_expression [299] = 'va_end(args)'
          function: identifier [1] = 'va_end'
          arguments: argument_list [309] = '(args)'
            ( [5] = '('
            identifier [1] = 'args'
            ) [8] = ')'
        ; [42] = ';'
      expression_statement [266] = 'printf("\n");'
        call_expression [299] = 'printf("\n")'
          function: identifier [1] = 'printf'
          arguments: argument_list [309] = '("\n")'
            ( [5] = '('
            string_literal [320] = '"\n"'
              " [152] = '"'
              escape_sequence [154] = '\n'
              " [152] = '"'
            ) [8] = ')'
        ; [42] = ';'
      } [65] = '}'
  comment [160] = '/**'
  function_definition [196] = 'uint32_t reverse_bits(uint32_t num) {'
    type: primitive_type [93] = 'uint32_t'
    declarator: function_declarator [230] = 'reverse_bits(uint32_t num)'
      declarator: identifier [1] = 'reverse_bits'
      parameters: parameter_list [258] = '(uint32_t num)'
        ( [5] = '('
        parameter_declaration [260] = 'uint32_t num'
          type: primitive_type [93] = 'uint32_t'
          declarator: identifier [1] = 'num'
        ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      declaration [198] = 'uint32_t result = 0;'
        type: primitive_type [93] = 'uint32_t'
        declarator: init_declarator [240] = 'result = 0'
          declarator: identifier [1] = 'result'
          = [73] = '='
          value: number_literal [141] = '0'
        ; [42] = ';'
      for_statement [273] = 'for (int i = 0; i < 32; i++) {'
        for [105] = 'for'
        ( [5] = '('
        initializer: declaration [198] = 'int i = 0;'
          type: primitive_type [93] = 'int'
          declarator: init_declarator [240] = 'i = 0'
            declarator: identifier [1] = 'i'
            = [73] = '='
            value: number_literal [141] = '0'
          ; [42] = ';'
        condition: binary_expression [290] = 'i < 32'
          left: identifier [1] = 'i'
          operator: < [39] = '<'
          right: number_literal [141] = '32'
        ; [42] = ';'
        update: update_expression [291] = 'i++'
          argument: identifier [1] = 'i'
          operator: ++ [126] = '++'
        ) [8] = ')'
        body: compound_statement [241] = '{'
          { [64] = '{'
          if_statement [267] = 'if (num & (1U << i)) {'
            if [98] = 'if'
            condition: parenthesized_expression [312] = '(num & (1U << i))'
              ( [5] = '('
              binary_expression [290] = 'num & (1U << i)'
                left: identifier [1] = 'num'
                operator: & [33] = '&'
                right: parenthesized_expression [312] = '(1U << i)'
                  ( [5] = '('
                  binary_expression [290] = '1U << i'
                    left: number_literal [141] = '1U'
                    operator: << [40] = '<<'
                    right: identifier [1] = 'i'
                  ) [8] = ')'
              ) [8] = ')'
            consequence: compound_statement [241] = '{'
              { [64] = '{'
              expression_statement [266] = 'result |= (1U << (31 - i));'
                assignment_expression [287] = 'result |= (1U << (31 - i))'
                  left: identifier [1] = 'result'
                  operator: |= [124] = '|='
                  right: parenthesized_expression [312] = '(1U << (31 - i))'
                    ( [5] = '('
                    binary_expression [290] = '1U << (31 - i)'
                      left: number_literal [141] = '1U'
                      operator: << [40] = '<<'
                      right: parenthesized_expression [312] = '(31 - i)'
                        ( [5] = '('
                        binary_expression [290] = '31 - i'
                          left: number_literal [141] = '31'
                          operator: - [24] = '-'
                          right: identifier [1] = 'i'
                        ) [8] = ')'
                    ) [8] = ')'
                ; [42] = ';'
              } [65] = '}'
          } [65] = '}'
      return_statement [275] = 'return result;'
        return [106] = 'return'
        identifier [1] = 'result'
        ; [42] = ';'
      } [65] = '}'
  comment [160] = '/**'
  function_definition [196] = 'int main(int argc, char *argv[]) {'
    type: primitive_type [93] = 'int'
    declarator: function_declarator [230] = 'main(int argc, char *argv[])'
      declarator: identifier [1] = 'main'
      parameters: parameter_list [258] = '(int argc, char *argv[])'
        ( [5] = '('
        parameter_declaration [260] = 'int argc'
          type: primitive_type [93] = 'int'
          declarator: identifier [1] = 'argc'
        , [7] = ','
        parameter_declaration [260] = 'char *argv[]'
          type: primitive_type [93] = 'char'
          declarator: pointer_declarator [226] = '*argv[]'
            * [26] = '*'
            declarator: array_declarator [236] = 'argv[]'
              declarator: identifier [1] = 'argv'
              [ [70] = '['
              ] [72] = ']'
        ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      expression_statement [266] = 'printf("C Comprehensive Example\n");'
        call_expression [299] = 'printf("C Comprehensive Example\n")'
          function: identifier [1] = 'printf'
          arguments: argument_list [309] = '("C Comprehensive Example\n")'
            ( [5] = '('
            string_literal [320] = '"C Comprehensive Example\n"'
              " [152] = '"'
              string_content [153] = 'C Comprehensive Example'
              escape_sequence [154] = '\n'
              " [152] = '"'
            ) [8] = ')'
        ; [42] = ';'
      expression_statement [266] = 'printf("Arguments: %d\n", argc);'
        call_expression [299] = 'printf("Arguments: %d\n", argc)'
          function: identifier [1] = 'printf'
          arguments: argument_list [309] = '("Arguments: %d\n", argc)'
            ( [5] = '('
            string_literal [320] = '"Arguments: %d\n"'
              " [152] = '"'
              string_content [153] = 'Arguments: %d'
              escape_sequence [154] = '\n'
              " [152] = '"'
            , [7] = ','
            identifier [1] = 'argc'
            ) [8] = ')'
        ; [42] = ';'
      if_statement [267] = 'if (argc > 1) {'
        if [98] = 'if'
        condition: parenthesized_expression [312] = '(argc > 1)'
          ( [5] = '('
          binary_expression [290] = 'argc > 1'
            left: identifier [1] = 'argc'
            operator: > [36] = '>'
            right: number_literal [141] = '1'
          ) [8] = ')'
        consequence: compound_statement [241] = '{'
          { [64] = '{'
          expression_statement [266] = 'printf("First argument: %s\n", argv[1]);'
            call_expression [299] = 'printf("First argument: %s\n", argv[1])'
              function: identifier [1] = 'printf'
              arguments: argument_list [309] = '("First argument: %s\n", argv[1])'
                ( [5] = '('
                string_literal [320] = '"First argument: %s\n"'
                  " [152] = '"'
                  string_content [153] = 'First argument: %s'
                  escape_sequence [154] = '\n'
                  " [152] = '"'
                , [7] = ','
                subscript_expression [298] = 'argv[1]'
                  argument: identifier [1] = 'argv'
                  [ [70] = '['
                  index: number_literal [141] = '1'
                  ] [72] = ']'
                ) [8] = ')'
            ; [42] = ';'
          } [65] = '}'
      comment [160] = '// Test basic arithmetic operations'
      declaration [198] = 'int sum = add(5, 3);'
        type: primitive_type [93] = 'int'
        declarator: init_declarator [240] = 'sum = add(5, 3)'
          declarator: identifier [1] = 'sum'
          = [73] = '='
          value: call_expression [299] = 'add(5, 3)'
            function: identifier [1] = 'add'
            arguments: argument_list [309] = '(5, 3)'
              ( [5] = '('
              number_literal [141] = '5'
              , [7] = ','
              number_literal [141] = '3'
              ) [8] = ')'
        ; [42] = ';'
      expression_statement [266] = 'printf("Sum: %d\n", sum);'
        call_expression [299] = 'printf("Sum: %d\n", sum)'
          function: identifier [1] = 'printf'
          arguments: argument_list [309] = '("Sum: %d\n", sum)'
            ( [5] = '('
            string_literal [320] = '"Sum: %d\n"'
              " [152] = '"'
              string_content [153] = 'Sum: %d'
              escape_sequence [154] = '\n'
              " [152] = '"'
            , [7] = ','
            identifier [1] = 'sum'
            ) [8] = ')'
        ; [42] = ';'
      comment [160] = '// Test structure usage and pointer operations'
      declaration [198]
        type: struct_specifier [249] = 'struct Point'
          struct [96] = 'struct'
          name: type_identifier [362] = 'Point'
        declarator: init_declarator [240] = 'p = {10.5f, 20.3f, "test point"}'
          declarator: identifier [1] = 'p'
          = [73] = '='
          value: initializer_list [313] = '{10.5f, 20.3f, "test point"}'
            { [64] = '{'
            number_literal [141] = '10.5f'
            , [7] = ','
            number_literal [141] = '20.3f'
            , [7] = ','
            string_literal [320] = '"test point"'
              " [152] = '"'
              string_content [153] = 'test point'
              " [152] = '"'
            } [65] = '}'
        ; [42] = ';'
      expression_statement [266] = 'print_point(&p);'
        call_expression [299] = 'print_point(&p)'
          function: identifier [1] = 'print_point'
          arguments: argument_list [309] = '(&p)'
            ( [5] = '('
            pointer_expression [288] = '&p'
              operator: & [33] = '&'
              argument: identifier [1] = 'p'
            ) [8] = ')'
        ; [42] = ';'
      comment [160] = '// Test dynamic memory allocation and management'
      declaration [198]
        type: type_identifier [362] = 'Rectangle'
        declarator: init_declarator [240] = '*rect = create_rectangle(100, 200, p)'
          declarator: pointer_declarator [226] = '*rect'
            * [26] = '*'
            declarator: identifier [1] = 'rect'
          = [73] = '='
          value: call_expression [299] = 'create_rectangle(100, 200, p)'
            function: identifier [1] = 'create_rectangle'
            arguments: argument_list [309] = '(100, 200, p)'
              ( [5] = '('
              number_literal [141] = '100'
              , [7] = ','
              number_literal [141] = '200'
              , [7] = ','
              identifier [1] = 'p'
              ) [8] = ')'
        ; [42] = ';'
      if_statement [267] = 'if (rect) {'
        if [98] = 'if'
        condition: parenthesized_expression [312] = '(rect)'
          ( [5] = '('
          identifier [1] = 'rect'
          ) [8] = ')'
        consequence: compound_statement [241] = '{'
          { [64] = '{'
          expression_statement [266]
            call_expression [299]
              function: identifier [1] = 'printf'
              arguments: argument_list [309] = '("Rectangle: %dx%d at (%.1f, %.1f)\n", '
                ( [5] = '('
                string_literal [320] = '"Rectangle: %dx%d at (%.1f, %.1f)\n"'
                  " [152] = '"'
                  string_content [153] = 'Rectangle: %dx%d at (%.1f, %.1f)'
                  escape_sequence [154] = '\n'
                  " [152] = '"'
                , [7] = ','
                field_expression [310] = 'rect->width'
                  argument: identifier [1] = 'rect'
                  operator: -> [140] = '->'
                  field: field_identifier [360] = 'width'
                , [7] = ','
                field_expression [310] = 'rect->height'
                  argument: identifier [1] = 'rect'
                  operator: -> [140] = '->'
                  field: field_identifier [360] = 'height'
                , [7] = ','
                field_expression [310] = 'rect->origin.x'
                  argument: field_expression [310] = 'rect->origin'
                    argument: identifier [1] = 'rect'
                    operator: -> [140] = '->'
                    field: field_identifier [360] = 'origin'
                  operator: . [139] = '.'
                  field: field_identifier [360] = 'x'
                , [7] = ','
                field_expression [310] = 'rect->origin.y'
                  argument: field_expression [310] = 'rect->origin'
                    argument: identifier [1] = 'rect'
                    operator: -> [140] = '->'
                    field: field_identifier [360] = 'origin'
                  operator: . [139] = '.'
                  field: field_identifier [360] = 'y'
                ) [8] = ')'
            ; [42] = ';'
          expression_statement [266] = 'free(rect);'
            call_expression [299] = 'free(rect)'
              function: identifier [1] = 'free'
              arguments: argument_list [309] = '(rect)'
                ( [5] = '('
                identifier [1] = 'rect'
                ) [8] = ')'
            ; [42] = ';'
          comment [160] = '// Proper memory cleanup'
          } [65] = '}'
      comment [160] = '// Test complex language features'
      expression_statement [266] = 'complex_function();'
        call_expression [299] = 'complex_function()'
          function: identifier [1] = 'complex_function'
          arguments: argument_list [309] = '()'
            ( [5] = '('
            ) [8] = ')'
        ; [42] = ';'
      comment [160] = '// Test bit manipulation algorithms'
      declaration [198] = 'uint32_t original = 0x12345678;'
        type: primitive_type [93] = 'uint32_t'
        declarator: init_declarator [240] = 'original = 0x12345678'
          declarator: identifier [1] = 'original'
          = [73] = '='
          value: number_literal [141] = '0x12345678'
        ; [42] = ';'
      declaration [198]
        type: primitive_type [93] = 'uint32_t'
        declarator: init_declarator [240] = 'reversed = reverse_bits(original)'
          declarator: identifier [1] = 'reversed'
          = [73] = '='
          value: call_expression [299] = 'reverse_bits(original)'
            function: identifier [1] = 'reverse_bits'
            arguments: argument_list [309] = '(original)'
              ( [5] = '('
              identifier [1] = 'original'
              ) [8] = ')'
        ; [42] = ';'
      expression_statement [266]
        call_expression [299]
          function: identifier [1] = 'printf'
          arguments: argument_list [309]
            ( [5] = '('
            string_literal [320] = '"Original: 0x%08X, Reversed: 0x%08X\n"'
              " [152] = '"'
              string_content [153] = 'Original: 0x%08X, Reversed: 0x%08X'
              escape_sequence [154] = '\n'
              " [152] = '"'
            , [7] = ','
            identifier [1] = 'original'
            , [7] = ','
            identifier [1] = 'reversed'
            ) [8] = ')'
        ; [42] = ';'
      comment [160] = '// Test variadic function capabilities'
      expression_statement [266]
        call_expression [299]
          function: identifier [1] = 'debug_log'
          arguments: argument_list [309]
            ( [5] = '('
            string_literal [320]
              " [152] = '"'
              string_content [153] = 'Debug message with values: %d, %s, %.2f'
              " [152] = '"'
            , [7] = ','
            number_literal [141] = '42'
            , [7] = ','
            string_literal [320] = '"hello"'
              " [152] = '"'
              string_content [153] = 'hello'
              " [152] = '"'
            , [7] = ','
            number_literal [141] = '3.14'
            ) [8] = ')'
        ; [42] = ';'
      return_statement [275] = 'return EXIT_SUCCESS;'
        return [106] = 'return'
        identifier [1] = 'EXIT_SUCCESS'
        ; [42] = ';'
      } [65] = '}'
  comment [160] = '/**'
  function_definition [196] = 'static void helper_function(void) {'
    storage_class_specifier [242] = 'static'
      static [71] = 'static'
    type: primitive_type [93] = 'void'
    declarator: function_declarator [230] = 'helper_function(void)'
      declarator: identifier [1] = 'helper_function'
      parameters: parameter_list [258] = '(void)'
        ( [5] = '('
        parameter_declaration [260] = 'void'
          type: primitive_type [93] = 'void'
        ) [8] = ')'
    body: compound_statement [241] = '{'
      { [64] = '{'
      declaration [198] = 'static int call_count = 0;'
        storage_class_specifier [242] = 'static'
          static [71] = 'static'
        type: primitive_type [93] = 'int'
        declarator: init_declarator [240] = 'call_count = 0'
          declarator: identifier [1] = 'call_count'
          = [73] = '='
          value: number_literal [141] = '0'
        ; [42] = ';'
      comment [160] = '/**< Static counter preserves state */'
      expression_statement [266] = 'call_count++;'
        update_expression [291] = 'call_count++'
          argument: identifier [1] = 'call_count'
          operator: ++ [126] = '++'
        ; [42] = ';'
      expression_statement [266]
        call_expression [299]
          function: identifier [1] = 'printf'
          arguments: argument_list [309] = '("Helper called %d times\n", call_count)'
            ( [5] = '('
            string_literal [320] = '"Helper called %d times\n"'
              " [152] = '"'
              string_content [153] = 'Helper called %d times'
              escape_sequence [154] = '\n'
              " [152] = '"'
            , [7] = ','
            identifier [1] = 'call_count'
            ) [8] = ')'
        ; [42] = ';'
      } [65] = '}'
```

## Node Type Statistics

| Node Type | Count | Max Depth |
|-----------|-------|----------|
| ! | 1 | 6 |
| " | 52 | 12 |
| #define | 3 | 2 |
| #include | 6 | 2 |
| % | 1 | 9 |
| & | 3 | 9 |
| && | 1 | 5 |
| ( | 73 | 12 |
| ) | 73 | 12 |
| * | 24 | 9 |
| + | 1 | 5 |
| ++ | 5 | 7 |
| , | 62 | 11 |
| - | 2 | 13 |
| -> | 11 | 10 |
| . | 6 | 9 |
| ... | 2 | 5 |
| : | 5 | 7 |
| ; | 102 | 9 |
| < | 6 | 7 |
| << | 2 | 11 |
| = | 28 | 6 |
| == | 2 | 8 |
| > | 3 | 7 |
| >= | 1 | 6 |
| ? | 1 | 7 |
| NULL | 2 | 7 |
| [ | 9 | 12 |
| ] | 9 | 12 |
| abstract_pointer_declarator | 4 | 8 |
| argument_list | 33 | 10 |
| array_declarator | 4 | 6 |
| assignment_expression | 6 | 8 |
| binary_expression | 20 | 12 |
| break | 3 | 7 |
| break_statement | 3 | 6 |
| call_expression | 33 | 9 |
| case | 2 | 6 |
| case_statement | 3 | 5 |
| cast_expression | 2 | 6 |
| comment | 67 | 5 |
| compound_statement | 23 | 7 |
| conditional_expression | 1 | 6 |
| const | 13 | 9 |
| declaration | 28 | 4 |
| default | 1 | 6 |
| do | 1 | 4 |
| do_statement | 1 | 3 |
| else | 1 | 7 |
| else_clause | 1 | 6 |
| enum | 1 | 3 |
| enum_specifier | 1 | 2 |
| enumerator | 3 | 4 |
| enumerator_list | 1 | 3 |
| escape_sequence | 17 | 10 |
| expression_statement | 37 | 8 |
| extern | 1 | 3 |
| field_declaration | 13 | 4 |
| field_declaration_list | 4 | 3 |
| field_expression | 17 | 9 |
| field_identifier | 30 | 10 |
| for | 2 | 4 |
| for_statement | 2 | 3 |
| function_declarator | 16 | 3 |
| function_definition | 10 | 1 |
| goto | 1 | 6 |
| goto_statement | 1 | 5 |
| identifier | 183 | 13 |
| if | 7 | 6 |
| if_statement | 7 | 5 |
| init_declarator | 20 | 5 |
| initializer_list | 6 | 6 |
| inline | 2 | 3 |
| labeled_statement | 1 | 3 |
| null | 2 | 6 |
| number_literal | 54 | 13 |
| parameter_declaration | 26 | 5 |
| parameter_list | 16 | 4 |
| parenthesized_declarator | 1 | 3 |
| parenthesized_expression | 16 | 11 |
| pointer_declarator | 18 | 5 |
| pointer_expression | 4 | 8 |
| preproc_arg | 3 | 2 |
| preproc_def | 1 | 1 |
| preproc_function_def | 2 | 1 |
| preproc_include | 6 | 1 |
| preproc_params | 2 | 2 |
| primitive_type | 64 | 8 |
| return | 8 | 6 |
| return_statement | 8 | 5 |
| sizeof | 2 | 8 |
| sizeof_expression | 2 | 7 |
| statement_identifier | 2 | 6 |
| static | 5 | 5 |
| storage_class_specifier | 8 | 4 |
| string_content | 25 | 12 |
| string_literal | 26 | 11 |
| struct | 14 | 7 |
| struct_specifier | 14 | 6 |
| subscript_expression | 5 | 11 |
| switch | 1 | 4 |
| switch_statement | 1 | 3 |
| system_lib_string | 6 | 2 |
| translation_unit | 1 | 0 |
| type_definition | 5 | 1 |
| type_descriptor | 3 | 7 |
| type_identifier | 28 | 7 |
| type_qualifier | 14 | 8 |
| typedef | 5 | 2 |
| unary_expression | 1 | 5 |
| union | 2 | 5 |
| union_specifier | 2 | 4 |
| update_expression | 5 | 6 |
| variadic_parameter | 1 | 4 |
| volatile | 1 | 3 |
| while | 2 | 4 |
| while_statement | 1 | 3 |
| { | 34 | 8 |
| |= | 1 | 9 |
| } | 34 | 8 |

**Total unique node types**: 120
